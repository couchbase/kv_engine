/**
 * //// stat_definitions.json
 *
 * stat_definitions.json contains definitions of the form:
 *
 * {
 * "key": "unique_enum_key",
 * "unit": "none",
 * "cbstat": "key_used_for_cbstats_{format_arg}",
 * "prometheus": {
 *     "family": "metric_family",
 *     "labels": {
 *         "label_key": "label_value"
 *     }
 * }
 * },
 *
 * * "key"
 *    globally unique key, used when adding stats to a collector:
 *     collector.addStat(Key::foobar, value);
 *
 * * "unit"
 *    name of a cb::stats::unit declaration, e.g., "bytes", "microseconds".
 *    see statistics/units.h for all values.
 *    Indicates what the internally tracked value represents.
 *    This is used to add the appropriate suffix to the Prometheus metric
 *    family ("..._bytes", "..._seconds") and scale the recorded value to the
 *    base unit required by Prometheus (nanoseconds -> seconds,
 *    kilobytes->bytes)
 *
 * * "cbstat"
 *    If set to false, this metric will not be exposed over cbstats.
 *
 *    If the key used for cbstats needs to be different than the enum
 *    e.g., has unacceptable characters, or needs formatting at runtime,
 *    it may be overriden here.
 *    For example:
 *     {
 *     "key": "vb_num",
 *     "unit": "count",
 *     "cbstat": "vb_{state}_num",
 *     "prometheus": {
 *         "family": "num_vbuckets"
 *     }
 *     },
 *    Uses a runtime "state" label in the cbstat key.
 *    The same stat may be added with a different state label:
 *     collector.withLabel("state", "active").addStat(Key::vb_num, value);
 *     collector.withLabel("state", "replica").addStat(Key::vb_num, otherValue);
 *    For Prometheus, this results in multiple time series under the family
 *    "num_vbuckets", with differing labels.
 *    CBstats instead needs to format the key "vb_{state}_num" to get back to
 *    a unique value, "vb_active_num", "vb_replica_num".
 *
 * * "prometheus"
 *    If set to false, this metric will not be exposed for prometheus.
 *    otherwise, object containing "family", "labels" keys, both optional.
 * ** "family"
 *    If absent, defaults to the value of "key".
 *    A non-unique metric family name. Several metrics can share the same
 *    metric family name, with differing labels:
 *    foobar{label="value"}
 *    foobar{label="value2"}
 * ** "labels"
 *    Fixed labels which distinguish this stat from others in the metric family.
 *    More labels may be added at runtime, but where a label is always fixed
 *    ahead of time, it should be specified here.
 *
 *
 * //// cb::stats::Key
 *
 * generated_stats.h declares an enum containing every "key" from the json.
 *   namespace cb::stats {
 *   enum class Key {
 *   default_evictions,
 *   default_curr_items,
 *   ...
 *
 * This enum is used when adding stats to a collector:
 * collector.addStats(Key::default_evictions, value);
 *
 * The underlying collector impl (cbstat or prometheus) will use the relevant
 * information from the definitions in the json file.
 *
 *
 * //// Examples
 * * minimal CBStats-only metric
 *     {
 *     "key": "some_unique_key",
 *     "unit": "none", // unit is only informational for cbstats
 *     "prometheus": false
 *     },
 *  the cbstat key will default to the enum key as it has not been overriden.
 * * minimal Prometheus-only metric
 *    {
 *    "key": "cmd_duration",
 *    "unit": "microseconds",
 *    "cbstat": false
 *    }
 *  the metric family defaults to the enum key, and no additional hard-coded
 *  labels are present (though more may be added at runtime, like the "bucket"
 *  label).
 */



[
/* default_engine stats */
    {
        "key": "default_evictions",
        "unit": "count",
        "cbstat": "evictions",
        "prometheus": {
            "family": "memcache_evictions"
        }
    },
    {
        "key": "default_curr_items",
        "unit": "count",
        "cbstat": "curr_items",
        "prometheus": {
            "family": "memcache_curr_items"
        },
        "description": "Number of active items in memory"
    },
    {
        "key": "default_total_items",
        "unit": "count",
        "cbstat": "total_items",
        "prometheus": {
            "family": "memcache_total_items"
        }
    },
    {
        "key": "default_bytes",
        "unit": "bytes",
        "cbstat": "bytes",
        "prometheus": {
            "family": "memcache_mem_size"
        },
        "description": "Engine's total memory usage"
    },
    {
        "key": "default_reclaimed",
        "unit": "count",
        "cbstat": "reclaimed",
        "prometheus": {
            "family": "memcache_reclaimed"
        }
    },
    {
        "key": "default_engine_maxbytes",
        "unit": "count",
        "cbstat": "engine_maxbytes",
        "prometheus": {
            "family": "memcache_engine_maxbytes"
        }
    },
/* TODO: applying a "kv_" prefix globally would be consistent but lead to kv_ep_
 *  for some stats. Providing metric family names without ep_ would avoid this
 * "All" stats group (doEngineStats)
 */
    {
        "key": "ep_num_workers",
        "unit": "count",
        "description": "Global number of shared worker threads"
    },
    {
        "key": "ep_bucket_priority",
        "unit": "none",
        "description": "Priority assigned to the bucket"
    },
/* TODO: make 0/1 rather than text for Prometheus? */
    {
        "key": "ep_total_enqueued",
        "unit": "count",
        "description": "Total number of items queued for persistence"
    },
    {
        "key": "ep_total_deduplicated",
        "unit": "count",
        "description": "Total number of items de-duplicated when queued to CheckpointManager"
    },
    {
        "key": "ep_expired_access",
        "unit": "count",
        "description": "Number of times an item was expired on application access."
    },
    {
        "key": "ep_expired_compactor",
        "unit": "count",
        "description": "Number of times an item was expired by the ep engine compactor"
    },
    {
        "key": "ep_expired_pager",
        "unit": "count",
        "description": "Number of times an item was expired by ep engine item pager"
    },
    {
        "key": "ep_queue_size",
        "unit": "count",
        "description": "Number of items queued for storage"
    },
    {
        "key": "ep_diskqueue_items",
        "unit": "count",
        "description": "Total items in disk queue"
    },
    {
        "key": "ep_commit_num",
        "unit": "count",
        "description": "Total number of write commits"
    },
    {
        "key": "ep_commit_time",
        "unit": "microseconds",
        "description": "Number of milliseconds of most recent commit"
    },
    {
        "key": "ep_commit_time_total",
        "unit": "microseconds",
        "description": "Cumulative milliseconds spent committing"
    },
    {
        "key": "ep_item_begin_failed",
        "unit": "count",
        "description": "Number of times a transaction failed to start due to storage errors"
    },
    {
        "key": "ep_item_commit_failed",
        "unit": "count",
        "description": "Number of times a transaction failed to commit due to storage errors"
    },
    {
        "key": "ep_item_flush_expired",
        "unit": "count",
        "description": "Number of times an item is not flushed due to the expiry of the item"
    },
    {
        "key": "ep_item_flush_failed",
        "unit": "count",
        "description": "Number of times an item failed to flush due to storage errors"
    },
    {
        "key": "ep_flusher_state",
        "unit": "none",
        "description": "Current state of the flusher thread"
    },
    {
        "key": "ep_flusher_todo",
        "unit": "count",
        "description": "Number of items currently being written"
    },
    {
        "key": "ep_total_persisted",
        "unit": "count",
        "description": "Total number of items persisted"
    },
    {
        "key": "ep_uncommitted_items",
        "unit": "count",
        "description": "The amount of items that have not been written to disk"
    },
    {
        "key": "ep_vbucket_del",
        "unit": "count",
        "description": "Number of vbucket deletion events"
    },
    {
        "key": "ep_vbucket_del_fail",
        "unit": "count",
        "description": "Number of failed vbucket deletion events"
    },
    {
        "key": "ep_flush_duration_total",
        "unit": "milliseconds",
        "description": "Cumulative milliseconds spent flushing"
    },
    {
        "key": "ep_persist_vbstate_total",
        "unit": "count",
        "description": "Total VB persist state to disk"
    },
    {
        "key": "mem_used",
        "unit": "bytes",
        "description": "Engine's total memory usage"
    },
    {
        "key": "mem_used_primary",
        "unit": "bytes",
        "prometheus": {
            "family": "domain_memory_used",
            "labels": {
                "domain": "primary"
            }
        }
    },
    {
        "key": "mem_used_secondary",
        "unit": "bytes",
        "prometheus": {
            "family": "domain_memory_used",
            "labels": {
                "domain": "secondary"
            }
        }
    },
    {
        "key": "mem_used_estimate",
        "unit": "bytes",
        "description": "Engine's total estimated memory usage This is a faster stat to read, but lags mem_used as it's only updated when a threshold is crossed see mem_used_merge_threshold"
    },
    {
        "key": "ep_mem_low_wat_percent",
        "unit": "percent",
        "description": "Low water mark (as a percentage)"
    },
    {
        "key": "ep_mem_high_wat_percent",
        "unit": "percent",
        "description": "High water mark (as a percentage)"
    },
/* TODO: it's not advised to have metric like:
 *   my_metric{label=a} 1
 *   my_metric{label=b} 6
 *   my_metric{label=total} 7
 *  as a total is inconvenient for aggregation, _but_ we do track
 * several stats which are logically totals which might include things _not_
 * available under any other metric. Exposing it under a different metric name
 * seems best. Note: "..._total" is expected to be reserved for Counters -
 * totals over time, not totals of other things.
 */
    {
        "key": "bytes",
        "unit": "bytes",
        "prometheus": {
            "family": "total_memory_used"
        },
        "description": "Engine's total memory usage"
    },
    {
        "key": "ep_kv_size",
        "unit": "bytes",
        "prometheus": {
            "family": "memory_used",
            "labels": {
                "for": "hashtable"
            }
        },
        "description": "Memory used to store item metadata, keys and values, no matter the vbucket's state. If an item's value is ejected, this stat will be decremented by the size of the item's value."
    },
    {
        "key": "ep_blob_num",
        "unit": "count",
        "description": "The number of blob objects in the cache"
    },
    {
        "key": "ep_blob_overhead",
        "unit": "bytes",
        "prometheus": {
            "family": "memory_overhead",
            "labels": {
                "for": "blobs"
            }
        },
        "description": "The \"unused\" memory caused by the allocator returning bigger chunks than requested"
    },
/* TODO: Assess what labels would actually be _useful_ for querying */
    {
        "key": "ep_value_size",
        "unit": "bytes",
        "prometheus": {
            "family": "memory_used",
            "labels": {
                "for": "blobs"
            }
        },
        "description": "Memory used to store values for resident keys"
    },
    {
        "key": "ep_storedval_size",
        "unit": "bytes",
        "prometheus": {
            "family": "memory_used",
            "labels": {
                "for": "storedvalues"
            }
        },
        "description": "Memory used by storedval objects"
    },
    {
        "key": "ep_storedval_overhead",
        "unit": "bytes",
        "prometheus": {
            "family": "memory_overhead",
            "labels": {
                "for": "storedvalues"
            }
        },
        "description": "The \"unused\" memory caused by the allocator returning bigger chunks than requested"
    },
    {
        "key": "ep_storedval_num",
        "unit": "count",
        "description": "The number of storedval objects allocated"
    },
    {
        "key": "ep_overhead",
        "unit": "bytes",
        "prometheus": {
            "family": "total_memory_overhead"
        },
        "description": "Extra memory used by transient data like persistence queue, replication queues, checkpoints, etc"
    },
    {
        "key": "ep_item_num",
        "unit": "count",
        "description": "The number of item objects allocated"
    },
    {
        "key": "ep_oom_errors",
        "unit": "count",
        "description": "Number of times unrecoverable OOMs happened while processing operations"
    },
    {
        "key": "ep_tmp_oom_errors",
        "unit": "count",
        "description": "Number of times temporary OOMs happened while processing operations"
    },
    {
        "key": "ep_mem_tracker_enabled",
        "unit": "none",
        "description": "True if memory usage tracker is enabled"
    },
    {
        "key": "ep_bg_fetched",
        "unit": "count",
        "description": "Number of items fetched from disk"
    },
    {
        "key": "ep_bg_meta_fetched",
        "unit": "count",
        "description": "Number of meta items fetched from disk"
    },
    {
        "key": "ep_bg_remaining_items",
        "unit": "count",
        "description": "Number of remaining bg fetch items"
    },
    {
        "key": "ep_bg_remaining_jobs",
        "unit": "count",
        "description": "Number of remaining bg fetch jobs"
    },
    {
        "key": "ep_num_pager_runs",
        "unit": "count",
        "description": "Number of times we ran pager loops to seek additional memory"
    },
    {
        "key": "ep_num_expiry_pager_runs",
        "unit": "count",
        "description": "Number of times we ran expiry pager loops to purge expired items from memory/disk"
    },
    {
        "key": "ep_num_freq_decayer_runs",
        "unit": "count",
        "description": "Number of times we ran the freq decayer task because a frequency counter has become saturated"
    },
    {
        "key": "ep_items_expelled_from_checkpoints",
        "unit": "count",
        "description": "Number of items expelled from checkpoints. Expelled refers to items that have been ejected from memory but are still considered to be part of the checkpoint."
    },
    {
        "key": "ep_items_rm_from_checkpoints",
        "unit": "count",
        "description": "Number of items removed from closed unreferenced checkpoints"
    },
    {
        "key": "ep_num_value_ejects",
        "unit": "count",
        "description": "Number of times item values got ejected from memory to disk"
    },
    {
        "key": "ep_num_eject_failures",
        "unit": "count",
        "description": "Number of items that could not be ejected"
    },
    {
        "key": "ep_num_not_my_vbuckets",
        "unit": "count",
        "description": "Number of times Not My VBucket exception happened during runtime"
    },
    {
        "key": "ep_pending_ops",
        "unit": "count",
        "description": "Number of ops awaiting pending vbuckets"
    },
    {
        "key": "ep_pending_ops_total",
        "unit": "count",
        "description": "Total blocked pending ops since reset"
    },
/* TODO: are total-over-uptime stats relevant for prometheus
 *  given the ability to sum over a time period?
 */
    {
        "key": "ep_pending_ops_max",
        "unit": "count",
        "description": "Max ops seen awaiting 1 pending vbucket"
    },
/* TODO: standardise labelling for "high watermark" style stats */
    {
        "key": "ep_pending_ops_max_duration",
        "unit": "microseconds",
        "description": "Max time (\u00b5s) used waiting on pending vbuckets"
    },
    {
        "key": "ep_pending_compactions",
        "unit": "count",
        "description": "Number of pending vbucket compactions"
    },
    {
        "key": "ep_compaction_failed",
        "unit": "count"
    },
    {
        "key": "ep_compaction_aborted",
        "unit": "count"
    },
    {
        "key": "ep_rollback_count",
        "unit": "count",
        "description": "Number of rollbacks on consumer"
    },
    {
        "key": "ep_vbucket_del_max_walltime",
        "unit": "microseconds",
        "description": "Max wall time (\u00b5s) spent by deleting a vbucket"
    },
    {
        "key": "ep_vbucket_del_avg_walltime",
        "unit": "microseconds",
        "description": "Avg wall time (\u00b5s) spent by deleting a vbucket"
    },
    {
        "key": "ep_bg_num_samples",
        "unit": "count",
        "description": "The number of samples included in the average"
    },
    {
        "key": "ep_bg_min_wait",
        "unit": "microseconds",
        "description": "The shortest time (\u00b5s) in the wait queue"
    },
    {
        "key": "ep_bg_max_wait",
        "unit": "microseconds",
        "description": "The longest time (\u00b5s) in the wait queue"
    },
    {
        "key": "ep_bg_wait_avg",
        "unit": "microseconds",
        "description": "The average wait time (\u00b5s) for an item before it's serviced by the dispatcher"
    },
/* TODO: derived from two stats. Decide
 *  whether to expose for prometheus
 */
    {
        "key": "ep_bg_min_load",
        "unit": "microseconds",
        "description": "The shortest load time (\u00b5s)"
    },
    {
        "key": "ep_bg_max_load",
        "unit": "microseconds",
        "description": "The longest load time (\u00b5s)"
    },
    {
        "key": "ep_bg_load_avg",
        "unit": "microseconds",
        "description": "The average time (\u00b5s) for an item to be loaded from the persistence layer"
    },
/* TODO: derived from two stats. Decide
 *  whether to expose for prometheus
 */
    {
        "key": "ep_bg_wait",
        "unit": "microseconds",
        "description": "The total elapse time for the wait queue"
    },
    {
        "key": "ep_bg_load",
        "unit": "microseconds",
        "description": "The total elapse time for items to be loaded from the persistence layer"
    },
    {
        "key": "ep_degraded_mode",
        "unit": "none",
        "description": "True if the engine is either warming up or data traffic is disabled"
    },
    {
        "key": "ep_num_access_scanner_runs",
        "unit": "count",
        "description": "Number of times we ran accesss scanner to snapshot working set"
    },
    {
        "key": "ep_num_access_scanner_skips",
        "unit": "count",
        "description": "Number of times accesss scanner task decided not to generate access log"
    },
    {
        "key": "ep_access_scanner_last_runtime",
        "unit": "seconds",
        "description": "Number of seconds that last access scanner task took to complete."
    },
/* TODO: relative to server start. Convert to absolute time? */
    {
        "key": "ep_access_scanner_num_items",
        "unit": "count",
        "description": "Number of items that last access scanner task swept to access log."
    },
    {
        "key": "ep_access_scanner_task_time",
        "unit": "none",
        "description": "Time of the next access scanner task (GMT), NOT_SCHEDULED if access scanner has been disabled"
    },
/* TODO: this is a string, expose numeric time for Prometheus */
    {
        "key": "ep_expiry_pager_task_time",
        "unit": "none",
        "description": "Time of the next expiry pager task (GMT), NOT_SCHEDULED if expiry pager has been disabled"
    },
/* TODO: this is a string, expose numeric time for Prometheus */
    {
        "key": "ep_startup_time",
        "unit": "seconds",
        "description": "System-generated engine startup time"
    },
    {
        "key": "ep_warmup_thread",
        "unit": "none",
        "description": "Warmup thread status"
    },
    {
        "key": "ep_warmup_time",
        "unit": "microseconds",
        "description": "Time (\u00b5s) spent by warming data"
    },
    {
        "key": "ep_warmup_oom",
        "unit": "count",
        "description": "OOMs encountered during warmup"
    },
    {
        "key": "ep_warmup_dups",
        "unit": "count",
        "description": "Duplicates encountered during warmup"
    },
    {
        "key": "ep_warmup_state",
        "unit": "none",
        "description": "The current state of the warmup thread"
    },
    {
        "key": "ep_warmup_key_count",
        "unit": "count",
        "description": "Number of keys warmed up"
    },
    {
        "key": "ep_warmup_value_count",
        "unit": "count",
        "description": "Number of values warmed up"
    },
    {
        "key": "ep_warmup_min_item_threshold",
        "unit": "count"
    },
    {
        "key": "ep_warmup_keys_time",
        "unit": "microseconds",
        "description": "Time (\u00b5s) spent by warming keys"
    },
    {
        "key": "ep_warmup_estimated_key_count",
        "unit": "none",
        "description": "Estimated number of keys in database"
    },
    {
        "key": "ep_warmup_estimate_time",
        "unit": "microseconds"
    },
    {
        "key": "ep_warmup_access_log",
        "unit": "none",
        "description": "Number of keys present in access log"
    },
    {
        "key": "ep_warmup_estimated_value_count",
        "unit": "none",
        "description": "Estimated number of values in database"
    },
    {
        "key": "ep_num_ops_get_meta",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "get_meta"
            }
        },
        "description": "Number of getMeta operations"
    },
    {
        "key": "ep_num_ops_set_meta",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "set_meta"
            }
        },
        "description": "Number of setWithMeta operations"
    },
    {
        "key": "ep_num_ops_del_meta",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "del_meta"
            }
        },
        "description": "Number of delWithMeta operations"
    },
    {
        "key": "ep_num_ops_set_meta_res_fail",
        "unit": "count",
        "prometheus": {
            "family": "ops_failed",
            "labels": {
                "op": "set_meta"
            }
        }
    },
    {
        "key": "ep_num_ops_del_meta_res_fail",
        "unit": "count",
        "prometheus": {
            "family": "ops_failed",
            "labels": {
                "op": "del_meta"
            }
        }
    },
    {
        "key": "ep_num_ops_set_ret_meta",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "set_ret_meta"
            }
        },
        "description": "Number of setRetMeta operations"
    },
    {
        "key": "ep_num_ops_del_ret_meta",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "del_ret_meta"
            }
        },
        "description": "Number of delRetMeta operations"
    },
    {
        "key": "ep_num_ops_get_meta_on_set_meta",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "get_meta_for_set_meta"
            }
        },
        "description": "Num of background getMeta operations spawn due to setWithMeta operations"
    },
    {
        "key": "ep_workload_pattern",
        "unit": "none",
        "description": "Workload pattern (mixed, read_heavy, write_heavy) monitored at runtime"
    },
    {
        "key": "ep_defragmenter_num_visited",
        "unit": "count",
        "description": "Number of items visited (considered for defragmentation) by the defragmenter task."
    },
    {
        "key": "ep_defragmenter_num_moved",
        "unit": "count",
        "description": "Number of items moved by the defragmentater task."
    },
    {
        "key": "ep_defragmenter_sv_num_moved",
        "unit": "count",
        "description": "Number of StoredValues moved by the defragmentater task."
    },
    {
        "key": "ep_item_compressor_num_visited",
        "unit": "count",
        "description": "Number of items visited (considered for compression) by the item compressor task."
    },
    {
        "key": "ep_item_compressor_num_compressed",
        "unit": "count",
        "description": "Number of items compressed by the item compressor task."
    },
    {
        "key": "ep_checkpoint_computed_max_size",
        "unit": "bytes"
    },
    {
        "key": "ep_cursors_dropped",
        "unit": "count",
        "description": "Number of cursors dropped by the checkpoint remover"
    },
    {
        "key": "ep_mem_freed_by_checkpoint_removal",
        "unit": "bytes",
        "description": "Amount of memory freed through ckpt removal"
    },
    {
        "key": "ep_mem_freed_by_checkpoint_item_expel",
        "unit": "bytes"
    },
    {
        "key": "ep_num_checkpoints",
        "unit": "count"
    },
    {
        "key": "ep_num_checkpoints_pending_destruction",
        "unit": "count",
        "description": "Number of checkpoints detached from CM and owned by Destroyers"
    },
    {
        "key": "ep_data_write_failed",
        "unit": "count",
        "description": "Total compaction and commit failures"
    },
    {
        "key": "ep_data_read_failed",
        "unit": "count",
        "description": "Total number of get failures"
    },
    {
        "key": "ep_io_document_write_bytes",
        "unit": "bytes"
    },
    {
        "key": "ep_io_total_read_bytes",
        "unit": "bytes",
        "description": "Total number of bytes read"
    },
    {
        "key": "ep_io_total_write_bytes",
        "unit": "bytes",
        "description": "Total number of bytes written"
    },
    {
        "key": "ep_io_compaction_read_bytes",
        "unit": "bytes",
        "description": "Total number of bytes read during compaction"
    },
    {
        "key": "ep_io_compaction_write_bytes",
        "unit": "bytes",
        "description": "Total number of bytes written during compaction"
    },
    {
        "key": "ep_io_bg_fetch_read_count",
        "unit": "count"
    },
    {
        "key": "ep_bg_fetch_avg_read_amplification",
        "unit": "ratio",
        "description": "Average read amplification for all background fetch operations - ratio of read()s to documents fetched."
    },
/* Magma stats */
    {
        "key": "ep_magma_sets",
        "unit": "count"
    },
    {
        "key": "ep_magma_gets",
        "unit": "count"
    },
    {
        "key": "ep_magma_inserts",
        "unit": "count"
    },
/* Compaction. */
    {
        "key": "ep_magma_compactions",
        "unit": "count"
    },
    {
        "key": "ep_magma_flushes",
        "unit": "count"
    },
    {
        "key": "ep_magma_ttl_compactions",
        "unit": "count"
    },
    {
        "key": "ep_magma_filecount_compactions",
        "unit": "count"
    },
    {
        "key": "ep_magma_writer_compactions",
        "unit": "count"
    },
/* Read amp. */
    {
        "key": "ep_magma_readamp",
        "unit": "ratio"
    },
    {
        "key": "ep_magma_readamp_get",
        "unit": "ratio"
    },
    {
        "key": "ep_magma_read_bytes",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_read_bytes_compact",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_read_bytes_get",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_bytes_outgoing",
        "unit": "bytes"
    },
/* ReadIOAmp. */
    {
        "key": "ep_magma_readio",
        "unit": "count"
    },
    {
        "key": "ep_magma_readioamp",
        "unit": "ratio"
    },
    {
        "key": "ep_magma_bytes_per_read",
        "unit": "ratio"
    },
/* Write amp. */
    {
        "key": "ep_magma_writeamp",
        "unit": "ratio"
    },
    {
        "key": "ep_magma_bytes_incoming",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_write_bytes",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_write_bytes_compact",
        "unit": "bytes"
    },
/* Fragmentation. */
    {
        "key": "ep_magma_logical_data_size",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_logical_disk_size",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_fragmentation",
        "unit": "ratio"
    },
/* Disk usage. */
    {
        "key": "ep_magma_total_disk_usage",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_wal_disk_usage",
        "unit": "bytes"
    },
/* Memory usage. */
    {
        "key": "ep_magma_read_ahead_buffer_mem_used",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_lsmtree_object_mem_used",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_table_object_mem_used",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_histogram_mem_used",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_block_cache_mem_used",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_write_cache_mem_used",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_wal_mem_used",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_table_meta_mem_used",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_buffer_mem_used",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_bloom_filter_mem_used",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_total_mem_used",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_tree_snapshot_mem_used",
        "unit": "bytes"
    },
    {
        "key": "ep_magma_index_resident_ratio",
        "unit": "ratio"
    },
/* Block cache. */
    {
        "key": "ep_magma_block_cache_hits",
        "unit": "count"
    },
    {
        "key": "ep_magma_block_cache_misses",
        "unit": "count"
    },
    {
        "key": "ep_magma_block_cache_hit_ratio",
        "unit": "ratio"
    },
/* SST file count. */
    {
        "key": "ep_magma_tables_created",
        "unit": "count"
    },
    {
        "key": "ep_magma_tables_deleted",
        "unit": "count"
    },
    {
        "key": "ep_magma_tables",
        "unit": "count"
    },
/* NSync. */
    {
        "key": "ep_magma_syncs",
        "unit": "count"
    },
    {
        "key": "ep_rocksdb_kMemTableTotal",
        "unit": "bytes",
        "description": "Total size of all Memtables"
    },
    {
        "key": "ep_rocksdb_kMemTableUnFlushed",
        "unit": "bytes",
        "description": "Total size of immutable Memtables"
    },
    {
        "key": "ep_rocksdb_kTableReadersTotal",
        "unit": "bytes",
        "description": "Memory used by Index/Filter blocks"
    },
    {
        "key": "ep_rocksdb_kCacheTotal",
        "unit": "bytes",
        "description": "Size of the Block Cache"
    },
    {
        "key": "ep_rocksdb_default_kSizeAllMemTables",
        "unit": "bytes",
        "description": "Total MT size for default CFs"
    },
    {
        "key": "ep_rocksdb_seqno_kSizeAllMemTables",
        "unit": "bytes",
        "description": "Total MT size for seqno CFs"
    },
    {
        "key": "ep_rocksdb_block_cache_data_hit_ratio",
        "unit": "ratio",
        "description": "Cache hit ratio for Data blocks"
    },
    {
        "key": "ep_rocksdb_block_cache_index_hit_ratio",
        "unit": "ratio",
        "description": "Cache hit ratio for Index blocks"
    },
    {
        "key": "ep_rocksdb_block_cache_filter_hit_ratio",
        "unit": "ratio",
        "description": "Cache hit ratio for Filter blocks"
    },
    {
        "key": "ep_rocksdb_default_kTotalSstFilesSize",
        "unit": "bytes",
        "description": "Total SST size for default CFs"
    },
    {
        "key": "ep_rocksdb_seqno_kTotalSstFilesSize",
        "unit": "bytes",
        "description": "Total SST size for seqno CFs"
    },
    {
        "key": "ep_rocksdb_scan_totalSeqnoHits",
        "unit": "count"
    },
    {
        "key": "ep_rocksdb_scan_oldSeqnoHits",
        "unit": "count"
    },
/* EPBucket::getFileStats */
    {
        "key": "ep_db_data_size",
        "unit": "bytes",
        "description": "Total size of valid data in db files"
    },
    {
        "key": "ep_db_file_size",
        "unit": "bytes",
        "description": "Total size of the db files"
    },
    {
        "key": "ep_db_prepare_size",
        "unit": "bytes",
        "description": "Total size of SyncWrite prepares in db files"
    },
/* Timing stats */
    {
        "key": "cmd_duration",
        "unit": "microseconds",
        "cbstat": false
    },
    {
        "key": "bg_wait",
        "unit": "microseconds",
        "description": "bg fetches waiting in the dispatcher queue"
    },
    {
        "key": "bg_load",
        "unit": "microseconds",
        "description": "bg fetches waiting for disk"
    },
    {
        "key": "pending_ops",
        "unit": "microseconds",
        "prometheus": false,
        "description": "client connections blocked for operations in pending vbuckets"
    },
    {
        "key": "access_scanner",
        "unit": "microseconds",
        "prometheus": false,
        "description": "access scanner run times"
    },
    {
        "key": "checkpoint_remover",
        "unit": "microseconds",
        "prometheus": false,
        "description": "checkpoint remover run times"
    },
    {
        "key": "item_pager",
        "unit": "microseconds",
        "prometheus": false,
        "description": "item pager run times"
    },
    {
        "key": "expiry_pager",
        "unit": "microseconds",
        "prometheus": false,
        "description": "expiry pager run times"
    },
    {
        "key": "storage_age",
        "unit": "microseconds",
        "prometheus": false,
        "description": "Analogous to ep_storage_age in main stats"
    },
    {
        "key": "set_with_meta",
        "unit": "microseconds",
        "prometheus": false,
        "description": "set_with_meta latencies"
    },
    {
        "key": "get_cmd",
        "unit": "microseconds",
        "prometheus": false,
        "description": "servicing get requests"
    },
    {
        "key": "store_cmd",
        "unit": "microseconds",
        "prometheus": false
    },
    {
        "key": "arith_cmd",
        "unit": "microseconds",
        "prometheus": false,
        "description": "servicing incr/decr requests"
    },
    {
        "key": "get_stats_cmd",
        "unit": "microseconds",
        "prometheus": false,
        "description": "servicing get_stats requests"
    },
    {
        "key": "get_vb_cmd",
        "unit": "microseconds",
        "prometheus": false,
        "description": "servicing vbucket status requests"
    },
    {
        "key": "set_vb_cmd",
        "unit": "microseconds",
        "prometheus": false,
        "description": "servicing vbucket set state commands"
    },
    {
        "key": "del_vb_cmd",
        "unit": "microseconds",
        "prometheus": false,
        "description": "servicing vbucket deletion commands"
    },
    {
        "key": "chk_persistence_cmd",
        "unit": "microseconds",
        "prometheus": false,
        "description": "waiting for checkpoint persistence"
    },
    {
        "key": "notify_io",
        "unit": "microseconds",
        "prometheus": false,
        "description": "waking blocked connections"
    },
    {
        "key": "disk_insert",
        "unit": "microseconds",
        "prometheus": {
            "family": "disk",
            "labels": {
                "op": "insert"
            }
        },
        "description": "waiting for disk to store a new item"
    },
    {
        "key": "disk_update",
        "unit": "microseconds",
        "prometheus": {
            "family": "disk",
            "labels": {
                "op": "update"
            }
        },
        "description": "waiting for disk to modify an existing item"
    },
    {
        "key": "disk_del",
        "unit": "microseconds",
        "prometheus": {
            "family": "disk",
            "labels": {
                "op": "del"
            }
        },
        "description": "waiting for disk to delete an item"
    },
    {
        "key": "disk_vb_del",
        "unit": "microseconds",
        "prometheus": {
            "family": "disk",
            "labels": {
                "op": "vb_del"
            }
        },
        "description": "waiting for disk to delete a vbucket"
    },
    {
        "key": "disk_commit",
        "unit": "microseconds",
        "prometheus": {
            "family": "disk",
            "labels": {
                "op": "commit"
            }
        },
        "description": "waiting for a commit after a batch of updates"
    },
    {
        "key": "item_alloc_sizes",
        "unit": "bytes",
        "description": "Item allocation size counters (in bytes)"
    },
/* TODO: this is not timing related but is in doTimingStats */
    {
        "key": "bg_batch_size",
        "unit": "count",
        "description": "Batch size for background fetches"
    },
/* TODO: this is not timing related but is in doTimingStats */
    {
        "key": "persistence_cursor_get_all_items",
        "unit": "microseconds",
        "prometheus": false,
        "description": "Time spent in fetching all items by persistence cursor from checkpoint queues"
    },
    {
        "key": "dcp_cursors_get_all_items",
        "unit": "microseconds",
        "prometheus": false,
        "description": "Time spent in fetching all items by all dcp cursors from checkpoint queues"
    },
    {
        "key": "sync_write_commit_majority",
        "unit": "microseconds",
        "prometheus": {
            "family": "sync_write_commit_duration",
            "labels": {
                "level": "majority"
            }
        },
        "description": "Commit duration for level=majority SyncWrites"
    },
    {
        "key": "sync_write_commit_majority_and_persist_on_master",
        "unit": "microseconds",
        "prometheus": {
            "family": "sync_write_commit_duration",
            "labels": {
                "level": "majority_and_persist_on_master"
            }
        },
        "description": "Commit duration for level=majorityPersistActive SyncWrites"
    },
    {
        "key": "sync_write_commit_persist_to_majority",
        "unit": "microseconds",
        "prometheus": {
            "family": "sync_write_commit_duration",
            "labels": {
                "level": "persist_to_majority"
            }
        },
        "description": "Commit duration for level=persistMajority SyncWrites"
    },
/* server_stats */
    {
        "key": "uptime",
        "unit": "seconds"
    },
    {
        "key": "stat_reset",
        "unit": "none"
    },
/* TODO: String indicating when stats were reset. Change
 *  to a numeric stat for Prometheus?
 */
    {
        "key": "time",
        "unit": "seconds"
    },
/* The following 3 stats are not exposed to prometheus as we don't expect their
 * values to change over time, assuming the system's clock configuration is
 * constant. However it is useful to have them show in cbstats so we can read
 * their current values either ad-hoc via cbstats or via cbcollect_info.
 */
    {
        "key": "clock_fine_overhead_ns",
        "unit": "none",
        "prometheus": false
    },
    {
        "key": "clock_coarse_overhead_ns",
        "unit": "none",
        "prometheus": false
    },
    {
        "key": "clock_measurement_period_ns",
        "unit": "none",
        "prometheus": false
    },
    {
        "key": "version",
        "unit": "none"
    },
/* version string */
    {
        "key": "memcached_version",
        "unit": "none"
    },
/* version string */
    {
        "key": "daemon_connections",
        "unit": "count"
    },
    {
        "key": "curr_connections",
        "unit": "count"
    },
    {
        "key": "system_connections",
        "unit": "count"
    },
    {
        "key": "total_connections",
        "unit": "count"
    },
/* total since start/reset */
    {
        "key": "connection_structures",
        "unit": "count"
    },
/* Amount of memory allocated by the daemon. */
    {
        "key": "daemon_memory_allocated",
        "unit": "bytes"
    },
/* Resident size of memory allocated by the daemon itself. */
    {
        "key": "daemon_memory_resident",
        "unit": "bytes"
    },
    {
        "key": "cmd_get",
        "unit": "count",
        "prometheus": false
    },
/* this is not exposed to Prometheus as it duplicates
 * the information provided by get_hits+get_misses
 */
    {
        "key": "cmd_set",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "set"
            }
        }
    },
    {
        "key": "cmd_flush",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "flush"
            }
        }
    },
    {
        "key": "cmd_lock",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "lock"
            }
        }
    },
    {
        "key": "cmd_subdoc_lookup",
        "unit": "count",
        "prometheus": {
            "family": "subdoc_ops",
            "labels": {
                "op": "lookup"
            }
        }
    },
    {
        "key": "cmd_subdoc_mutation",
        "unit": "count",
        "prometheus": {
            "family": "subdoc_ops",
            "labels": {
                "op": "mutation"
            }
        }
    },
    {
        "key": "bytes_subdoc_lookup_total",
        "unit": "bytes",
        "prometheus": {
            "family": "subdoc_lookup_searched"
        }
    },
/* type _bytes will be suffixed */
    {
        "key": "bytes_subdoc_lookup_extracted",
        "unit": "bytes",
        "prometheus": {
            "family": "subdoc_lookup_extracted"
        }
    },
    {
        "key": "bytes_subdoc_mutation_total",
        "unit": "bytes",
        "prometheus": {
            "family": "subdoc_mutation_updated"
        }
    },
    {
        "key": "bytes_subdoc_mutation_inserted",
        "unit": "bytes",
        "prometheus": {
            "family": "subdoc_mutation_inserted"
        }
    },
    {
        "key": "stat_timings_mem_usage",
        "unit": "bytes"
    },
/* aggregates over all buckets */
    {
        "key": "cmd_total_sets",
        "unit": "count"
    },
    {
        "key": "cmd_total_gets",
        "unit": "count"
    },
    {
        "key": "cmd_total_ops",
        "unit": "count"
    },
/* aggregates over multiple operations for a single bucket */
    {
        "key": "cmd_mutation",
        "unit": "count"
    },
    {
        "key": "cmd_lookup",
        "unit": "count"
    },
    {
        "key": "stat_timings",
        "unit": "microseconds",
        "cbstat": "stat:{stat_key}{arg_suffix}",
        "prometheus": false
    },
    {
        "key": "auth_cmds",
        "unit": "count"
    },
    {
        "key": "auth_errors",
        "unit": "count"
    },
    {
        "key": "get_hits",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "get",
                "result": "hit"
            }
        }
    },
    {
        "key": "get_misses",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "get",
                "result": "miss"
            }
        }
    },
    {
        "key": "delete_misses",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "delete",
                "result": "miss"
            }
        }
    },
    {
        "key": "delete_hits",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "delete",
                "result": "hit"
            }
        }
    },
    {
        "key": "incr_misses",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "incr",
                "result": "miss"
            }
        }
    },
    {
        "key": "incr_hits",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "incr",
                "result": "hit"
            }
        }
    },
    {
        "key": "decr_misses",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "decr",
                "result": "miss"
            }
        }
    },
    {
        "key": "decr_hits",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "decr",
                "result": "hit"
            }
        }
    },
    {
        "key": "cas_misses",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "cas",
                "result": "miss"
            }
        }
    },
    {
        "key": "cas_hits",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "cas",
                "result": "hit"
            }
        }
    },
    {
        "key": "cas_badval",
        "unit": "count",
        "prometheus": {
            "family": "ops",
            "labels": {
                "op": "cas",
                "result": "badval"
            }
        }
    },
    {
        "key": "bytes_read",
        "unit": "bytes",
        "prometheus": {
            "family": "read"
        }
    },
/* type _bytes will be suffixed */
    {
        "key": "bytes_written",
        "unit": "bytes",
        "prometheus": {
            "family": "written"
        }
    },
    {
        "key": "rejected_conns",
        "unit": "count"
    },
    {
        "key": "threads",
        "unit": "count"
    },
    {
        "key": "conn_yields",
        "unit": "count"
    },
    {
        "key": "iovused_high_watermark",
        "unit": "none"
    },
    {
        "key": "msgused_high_watermark",
        "unit": "none"
    },
    {
        "key": "lock_errors",
        "unit": "count"
    },
    {
        "key": "cmd_lookup_10s_count",
        "unit": "count"
    },
/* us suffix would be confusing in Prometheus as the stat is scaled to seconds */
    {
        "key": "cmd_lookup_10s_duration_us",
        "unit": "microseconds",
        "prometheus": {
            "family": "cmd_lookup_10s_duration"
        }
    },
    {
        "key": "cmd_mutation_10s_count",
        "unit": "count"
    },
/* us suffix would be confusing in Prometheus as the stat is scaled to seconds */
    {
        "key": "cmd_mutation_10s_duration_us",
        "unit": "microseconds",
        "prometheus": {
            "family": "cmd_mutation_10s_duration"
        }
    },
    {
        "key": "total_resp_errors",
        "unit": "count"
    },
    {
        "key": "audit_enabled",
        "unit": "none",
        "cbstat": "enabled",
        "prometheus": {
            "family": "audit_enabled"
        }
    },
    {
        "key": "audit_dropped_events",
        "unit": "count",
        "cbstat": "dropped_events",
        "prometheus": {
            "family": "audit_dropped_events"
        }
    },
    {
        "key": "vb_num",
        "unit": "count",
        "cbstat": "vb_{state}_num",
        "prometheus": {
            "family": "num_vbuckets"
        }
    },
    {
        "key": "vb_curr_items",
        "unit": "count",
        "cbstat": "vb_{state}_curr_items",
        "prometheus": {
            "family": "vb_curr_items"
        }
    },
    {
        "key": "vb_hp_vb_req_size",
        "unit": "count",
        "cbstat": "vb_{state}_hp_vb_req_size",
        "prometheus": {
            "family": "num_high_pri_requests"
        }
    },
    {
        "key": "vb_num_non_resident",
        "unit": "count",
        "cbstat": "vb_{state}_num_non_resident",
        "prometheus": {
            "family": "vb_num_non_resident"
        }
    },
    {
        "key": "vb_perc_mem_resident",
        "unit": "percent",
        "cbstat": "vb_{state}_perc_mem_resident",
        "prometheus": {
            "family": "vb_perc_mem_resident"
        }
    },
    {
        "key": "vb_eject",
        "unit": "count",
        "cbstat": "vb_{state}_eject",
        "prometheus": {
            "family": "vb_eject"
        }
    },
    {
        "key": "vb_expired",
        "unit": "count",
        "cbstat": "vb_{state}_expired",
        "prometheus": {
            "family": "vb_expired"
        }
    },
    {
        "key": "vb_meta_data_memory",
        "unit": "bytes",
        "cbstat": "vb_{state}_meta_data_memory",
        "prometheus": {
            "family": "vb_meta_data_memory"
        }
    },
    {
        "key": "vb_meta_data_disk",
        "unit": "bytes",
        "cbstat": "vb_{state}_meta_data_disk",
        "prometheus": {
            "family": "vb_meta_data_disk"
        }
    },
    {
        "key": "vb_checkpoint_memory",
        "unit": "bytes",
        "cbstat": "vb_{state}_checkpoint_memory",
        "prometheus": {
            "family": "vb_checkpoint_memory"
        }
    },
    {
        "key": "vb_checkpoint_memory_queue",
        "unit": "bytes",
        "cbstat": "vb_{state}_checkpoint_memory_queue",
        "prometheus": {
            "family": "vb_checkpoint_memory_queue"
        }
    },
    {
        "key": "vb_checkpoint_memory_overhead_allocator",
        "unit": "bytes",
        "cbstat": "vb_{state}_checkpoint_memory_overhead_allocator"
    },
    {
        "key": "vb_checkpoint_memory_overhead_allocator_queue",
        "unit": "bytes",
        "cbstat": "vb_{state}_checkpoint_memory_overhead_allocator_queue"
    },
    {
        "key": "vb_checkpoint_memory_overhead_allocator_index",
        "unit": "bytes",
        "cbstat": "vb_{state}_checkpoint_memory_overhead_allocator_index"
    },
    {
        "key": "vb_checkpoint_memory_overhead",
        "unit": "bytes",
        "cbstat": "vb_{state}_checkpoint_memory_overhead",
        "prometheus": {
            "family": "vb_checkpoint_memory_overhead"
        }
    },
    {
        "key": "vb_checkpoint_memory_overhead_queue",
        "unit": "bytes",
        "cbstat": "vb_{state}_checkpoint_memory_overhead_queue",
        "prometheus": {
            "family": "vb_checkpoint_memory_overhead_queue"
        }
    },
    {
        "key": "vb_checkpoint_memory_overhead_index",
        "unit": "bytes",
        "cbstat": "vb_{state}_checkpoint_memory_overhead_index",
        "prometheus": {
            "family": "vb_checkpoint_memory_overhead_index"
        }
    },
    {
        "key": "vb_mem_freed_by_checkpoint_item_expel",
        "unit": "bytes",
        "cbstat": "vb_{state}_mem_freed_by_checkpoint_item_expel"
    },
    {
        "key": "vb_mem_freed_by_checkpoint_removal",
        "unit": "bytes",
        "cbstat": "vb_{state}_mem_freed_by_checkpoint_removal"
    },
    {
        "key": "vb_ht_memory",
        "unit": "bytes",
        "cbstat": "vb_{state}_ht_memory",
        "prometheus": {
            "family": "vb_ht_memory"
        }
    },
    {
        "key": "vb_ht_item_memory",
        "unit": "bytes",
        "cbstat": "vb_{state}_ht_item_memory",
        "prometheus": {
            "family": "vb_ht_item_memory"
        }
    },
    {
        "key": "vb_ht_item_memory_uncompressed",
        "unit": "bytes",
        "cbstat": "vb_{state}_ht_item_memory_uncompressed",
        "prometheus": {
            "family": "vb_ht_item_memory_uncompressed"
        }
    },
    {
        "key": "vb_bloom_filter_memory",
        "unit": "bytes",
        "cbstat": "vb_{state}_bloom_filter_memory",
        "prometheus": {
            "family": "vb_bloom_filter_memory"
        }
    },
    {
        "key": "vb_ops_create",
        "unit": "count",
        "cbstat": "vb_{state}_ops_create",
        "prometheus": {
            "family": "vb_ops_create"
        }
    },
    {
        "key": "vb_ops_update",
        "unit": "count",
        "cbstat": "vb_{state}_ops_update",
        "prometheus": {
            "family": "vb_ops_update"
        }
    },
    {
        "key": "vb_ops_delete",
        "unit": "count",
        "cbstat": "vb_{state}_ops_delete",
        "prometheus": {
            "family": "vb_ops_delete"
        }
    },
    {
        "key": "vb_ops_get",
        "unit": "count",
        "cbstat": "vb_{state}_ops_get",
        "prometheus": {
            "family": "vb_ops_get"
        }
    },
    {
        "key": "vb_ops_reject",
        "unit": "count",
        "cbstat": "vb_{state}_ops_reject",
        "prometheus": {
            "family": "vb_ops_reject"
        }
    },
    {
        "key": "vb_queue_size",
        "unit": "count",
        "cbstat": "vb_{state}_queue_size",
        "prometheus": {
            "family": "vb_queue_size"
        }
    },
    {
        "key": "vb_queue_memory",
        "unit": "bytes",
        "cbstat": "vb_{state}_queue_memory",
        "prometheus": {
            "family": "vb_queue_memory"
        }
    },
    {
        "key": "vb_queue_age",
        "unit": "milliseconds",
        "cbstat": "vb_{state}_queue_age",
        "prometheus": {
            "family": "vb_queue_age"
        }
    },
    {
        "key": "vb_queue_pending",
        "unit": "bytes",
        "cbstat": "vb_{state}_queue_pending",
        "prometheus": {
            "family": "vb_queue_pending"
        }
    },
    {
        "key": "vb_queue_fill",
        "unit": "count",
        "cbstat": "vb_{state}_queue_fill",
        "prometheus": {
            "family": "vb_queue_fill"
        }
    },
    {
        "key": "vb_queue_drain",
        "unit": "count",
        "cbstat": "vb_{state}_queue_drain",
        "prometheus": {
            "family": "vb_queue_drain"
        }
    },
    {
        "key": "vb_rollback_item_count",
        "unit": "count",
        "cbstat": "vb_{state}_rollback_item_count",
        "prometheus": {
            "family": "vb_rollback_item_count"
        }
    },
    {
        "key": "curr_items",
        "unit": "count",
        "description": "Number of active items in memory"
    },
    {
        "key": "curr_temp_items",
        "unit": "count",
        "description": "Number of temporary items in memory"
    },
    {
        "key": "curr_items_tot",
        "unit": "count",
        "description": "Total number of items"
    },
    {
        "key": "vb_sync_write_accepted_count",
        "unit": "count",
        "cbstat": "vb_{state}_sync_write_accepted_count",
        "prometheus": {
            "family": "vb_sync_write_accepted_count"
        }
    },
    {
        "key": "vb_sync_write_committed_count",
        "unit": "count",
        "cbstat": "vb_{state}_sync_write_committed_count",
        "prometheus": {
            "family": "vb_sync_write_committed_count"
        }
    },
    {
        "key": "vb_sync_write_aborted_count",
        "unit": "count",
        "cbstat": "vb_{state}_sync_write_aborted_count",
        "prometheus": {
            "family": "vb_sync_write_aborted_count"
        }
    },
    {
        "key": "ep_vb_total",
        "unit": "count",
        "description": "Total vBuckets (count)"
    },
    {
        "key": "ep_total_new_items",
        "unit": "count",
        "description": "Total number of persisted new items"
    },
    {
        "key": "ep_total_del_items",
        "unit": "count",
        "description": "Total number of persisted deletions"
    },
    {
        "key": "ep_diskqueue_memory",
        "unit": "bytes",
        "description": "Total memory used in disk queue"
    },
    {
        "key": "ep_diskqueue_fill",
        "unit": "count",
        "description": "Total enqueued items on disk queue"
    },
    {
        "key": "ep_diskqueue_drain",
        "unit": "count",
        "description": "Total drained items on disk queue"
    },
    {
        "key": "ep_diskqueue_pending",
        "unit": "count",
        "description": "Total bytes of pending writes"
    },
    {
        "key": "ep_ht_item_memory",
        "unit": "bytes"
    },
    {
        "key": "ep_meta_data_memory",
        "unit": "bytes",
        "description": "Total memory used by meta data"
    },
    {
        "key": "ep_meta_data_disk",
        "unit": "bytes",
        "description": "Total disk used by meta data"
    },
    {
        "key": "ep_checkpoint_memory",
        "unit": "bytes",
        "description": "Memory of items in all checkpoints"
    },
    {
        "key": "ep_checkpoint_memory_overhead_allocator",
        "unit": "bytes",
        "description": "Mem of all checkpoints struct - from allocator"
    },
    {
        "key": "ep_checkpoint_memory_pending_destruction",
        "unit": "bytes",
        "description": "Memory of checkpoint structures awaiting destruction by a background task"
    },
    {
        "key": "ep_checkpoint_memory_quota",
        "unit": "bytes",
        "description": "Max allocation allowed in all checkpoints"
    },
    {
        "key": "ep_checkpoint_memory_recovery_upper_mark_bytes",
        "unit": "none"
    },
    {
        "key": "ep_checkpoint_memory_recovery_lower_mark_bytes",
        "unit": "none"
    },
    {
        "key": "ep_total_cache_size",
        "unit": "bytes",
        "description": "The total byte size of all items, no matter the vbucket's state, no matter if an item's value is ejected"
    },
    {
        "key": "rollback_item_count",
        "unit": "count",
        "description": "Num of items rolled back"
    },
    {
        "key": "ep_num_non_resident",
        "unit": "count",
        "description": "The number of non-resident items"
    },
    {
        "key": "ep_chk_persistence_remains",
        "unit": "count",
        "description": "Number of remaining vbuckets for checkpoint persistence"
    },
    {
        "key": "ep_hlc_drift",
        "unit": "microseconds",
        "cbstat": "ep_{state}_hlc_drift"
    },
    {
        "key": "ep_hlc_drift_count",
        "unit": "count",
        "cbstat": "ep_{state}_hlc_drift_count"
    },
    {
        "key": "ep_ahead_exceptions",
        "unit": "count",
        "cbstat": "ep_{state}_ahead_exceptions"
    },
    {
        "key": "ep_behind_exceptions",
        "unit": "count",
        "cbstat": "ep_{state}_behind_exceptions"
    },
    {
        "key": "ep_clock_cas_drift_threshold_exceeded",
        "unit": "count",
        "description": "ep_active_ahead_exceptions + ep_replica_ahead_exceptions"
    },
    {
        "key": "datatype_count",
        "unit": "count",
        "cbstat": "ep_{vbucket_state}_datatype_{datatype}"
    },
    {
        "key": "vb_auto_delete_count",
        "unit": "count",
        "cbstat": "vb_{state}_auto_delete_count",
        "prometheus": {
            "family": "vb_auto_delete_count"
        }
    },
    {
        "key": "vb_ht_tombstone_purged_count",
        "unit": "count",
        "cbstat": "vb_{state}_ht_tombstone_purged_count",
        "prometheus": {
            "family": "vb_ht_tombstone_purged_count"
        }
    },
    {
        "key": "vb_seqlist_count",
        "unit": "count",
        "cbstat": "vb_{state}_seqlist_count",
        "prometheus": {
            "family": "vb_seqlist_count"
        }
    },
    {
        "key": "vb_seqlist_deleted_count",
        "unit": "count",
        "cbstat": "vb_{state}_seqlist_deleted_count",
        "prometheus": {
            "family": "vb_seqlist_deleted_count"
        }
    },
    {
        "key": "vb_seqlist_purged_count",
        "unit": "count",
        "cbstat": "vb_{state}_seqlist_purged_count",
        "prometheus": {
            "family": "vb_seqlist_purged_count"
        }
    },
    {
        "key": "vb_seqlist_read_range_count",
        "unit": "count",
        "cbstat": "vb_{state}_seqlist_read_range_count",
        "prometheus": {
            "family": "vb_seqlist_read_range_count"
        }
    },
    {
        "key": "vb_seqlist_stale_count",
        "unit": "count",
        "cbstat": "vb_{state}_seqlist_stale_count",
        "prometheus": {
            "family": "vb_seqlist_stale_count"
        }
    },
    {
        "key": "vb_seqlist_stale_value_bytes",
        "unit": "bytes",
        "cbstat": "vb_{state}_seqlist_stale_value_bytes",
        "prometheus": {
            "family": "vb_seqlist_stale_value"
        }
    },
    {
        "key": "vb_seqlist_stale_metadata_bytes",
        "unit": "bytes",
        "cbstat": "vb_{state}_seqlist_stale_metadata_bytes",
        "prometheus": {
            "family": "vb_seqlist_stale_metadata"
        }
    },
    {
        "key": "connagg_connection_count",
        "unit": "count",
        "cbstat": "{connection_type}:count",
        "prometheus": {
            "family": "dcp_connection_count"
        }
    },
    {
        "key": "connagg_backoff",
        "unit": "count",
        "cbstat": "{connection_type}:backoff",
        "prometheus": {
            "family": "dcp_backoff"
        }
    },
    {
        "key": "connagg_producer_count",
        "unit": "count",
        "cbstat": "{connection_type}:producer_count",
        "prometheus": {
            "family": "dcp_producer_count"
        }
    },
    {
        "key": "connagg_items_sent",
        "unit": "count",
        "cbstat": "{connection_type}:items_sent",
        "prometheus": {
            "family": "dcp_items_sent"
        }
    },
    {
        "key": "connagg_items_remaining",
        "unit": "count",
        "cbstat": "{connection_type}:items_remaining",
        "prometheus": {
            "family": "dcp_items_remaining"
        }
    },
    {
        "key": "connagg_total_bytes",
        "unit": "bytes",
        "cbstat": "{connection_type}:total_bytes",
        "prometheus": {
            "family": "dcp_total_data_size"
        }
    },
    {
        "key": "connagg_total_uncompressed_data_size",
        "unit": "bytes",
        "cbstat": "{connection_type}:total_uncompressed_data_size",
        "prometheus": {
            "family": "dcp_total_uncompressed_data_size"
        }
    },
    {
        "key": "connagg_ready_queue_bytes",
        "unit": "bytes",
        "cbstat": "{connection_type}:ready_queue_bytes",
        "prometheus": {
            "family": "dcp_ready_queue_size"
        }
    },
/* aggregated dcp producer stats */
    {
        "key": "dcp_count",
        "unit": "count",
        "cbstat": "ep_dcp_count",
        "prometheus": false
    },
/* redundant in prometheus, is the sum
 * of consumer and producer
 */
    {
        "key": "dcp_consumer_count",
        "unit": "count",
        "cbstat": "ep_dcp_consumer_count",
        "prometheus": {
            "family": "dcp_count",
            "labels": {
                "type": "consumer"
            }
        }
    },
    {
        "key": "dcp_producer_count",
        "unit": "count",
        "cbstat": "ep_dcp_producer_count",
        "prometheus": {
            "family": "dcp_count",
            "labels": {
                "type": "producer"
            }
        }
    },
    {
        "key": "dcp_total_data_size",
        "unit": "bytes",
        "cbstat": "ep_dcp_total_bytes"
    },
    {
        "key": "dcp_total_uncompressed_data_size",
        "unit": "bytes",
        "cbstat": "ep_dcp_total_uncompressed_data_size"
    },
    {
        "key": "dcp_total_queue",
        "unit": "count",
        "cbstat": "ep_dcp_total_queue",
        "prometheus": false
    },
/* derivable from fill and sent */
    {
        "key": "dcp_queue_fill",
        "unit": "count",
        "cbstat": "ep_dcp_queue_fill"
    },
    {
        "key": "dcp_items_sent",
        "unit": "count",
        "cbstat": "ep_dcp_items_sent"
    },
    {
        "key": "dcp_items_remaining",
        "unit": "count",
        "cbstat": "ep_dcp_items_remaining"
    },
    {
        "key": "dcp_num_running_backfills",
        "unit": "count",
        "cbstat": "ep_dcp_num_running_backfills",
        "description": "Total number of running backfills across all dcp connections"
    },
    {
        "key": "dcp_max_running_backfills",
        "unit": "count",
        "cbstat": "ep_dcp_max_running_backfills",
        "description": "Max running backfills we can have across all dcp connections"
    },
    {
        "key": "manifest_uid",
        "unit": "none",
        "description": "The uid of the last manifest accepted from the cluster, only returned when all scopes are requested (no name or id provided)"
    },
    {
        "key": "manifest_force",
        "unit": "none",
        "cbstat": "force"
    },
    {
        "key": "collection_name",
        "unit": "none",
        "cbstat": "name"
    },
    {
        "key": "collection_scope_name",
        "unit": "none",
        "cbstat": "scope_name"
    },
    {
        "key": "collection_maxTTL",
        "unit": "seconds",
        "cbstat": "maxTTL"
    },
     {
        "key": "collection_metered",
        "unit": "none",
        "cbstat": "metered"
    },
    {
        "key": "scope_name",
        "unit": "none",
        "cbstat": "name"
    },
    {
        "key": "scope_data_limit",
        "unit": "none",
        "cbstat": "data_limit"
    },
    {
        "key": "scope_collection_count",
        "unit": "count",
        "cbstat": "collections"
    },
    {
        "key": "collection_mem_used",
        "unit": "bytes",
        "cbstat": "collections_mem_used"
    },
    {
        "key": "collection_item_count",
        "unit": "count",
        "cbstat": "items"
    },
    {
        "key": "collection_data_size",
        "unit": "bytes",
        "cbstat": "data_size"
    },
    {
        "key": "collection_ops_store",
        "unit": "count",
        "cbstat": "ops_store",
        "prometheus": {
            "family": "collection_ops",
            "labels": {
                "op": "store"
            }
        }
    },
    {
        "key": "collection_ops_delete",
        "unit": "count",
        "cbstat": "ops_delete",
        "prometheus": {
            "family": "collection_ops",
            "labels": {
                "op": "delete"
            }
        },
        "description": "Number of delete operations"
    },
    {
        "key": "collection_ops_get",
        "unit": "count",
        "cbstat": "ops_get",
        "prometheus": {
            "family": "collection_ops",
            "labels": {
                "op": "get"
            }
        }
    },
    // Metering
    {
        "key": "boot_timestamp",
        "unit": "seconds",
        "description": "The time KV last restarted (and counters reset)"
    },
    {
        "key": "meter_ru_total",
        "unit": "none",
        "description": "Total Read Units used by a bucket since reset"
    },
    {
        "key": "meter_wu_total",
        "unit": "none",
        "description": "Total Write Units used by a bucket since reset"
    },
    {
        "key": "meter_cu_total",
        "unit": "none",
        "description": "Total Compute Units used by a bucket since reset"
    },
    {
        "key": "op_count_total",
        "unit": "none",
        "description": "Total operations successfully executed for a bucket since reset"
    },
    {
        "key": "credit_ru_total",
        "unit": "none",
        "description": "Total Read Units refunded for a bucket (RU was charged, but operation failed) since reset"
    },
    {
        "key": "credit_wu_total",
        "unit": "none",
        "description": "Total Write Units refunded for a bucket (WU was charged, but operation failed) since reset"
    },
    {
        "key": "credit_cu_total",
        "unit": "none",
        "description": "Total Compute Units refunded for a bucket (CU was charged, but operation failed) since reset"
    },
    {
        "key": "reject_count_total",
        "unit": "none",
        "description": "Total number of operations rejected for a bucket since reset (e.g., invalid operations)"
    },
    {
        "key": "throttle_seconds_total",
        "unit": "none",
        "description": "Total time spent throttling requests for a bucket since reset"
    },
    {
        "key": "throttle_count_total",
        "unit": "none",
        "description": "Total number of times requests have been throttled for a bucket since reset"
    },
    {
        "key": "storage",
        "unit": "bytes",
        "description": "Total bytes on disk used by a bucket"
    }
]