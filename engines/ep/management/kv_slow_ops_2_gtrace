#!/usr/bin/env python3

#   Copyright 2018-Present Couchbase, Inc.
#
#   Use of this software is governed by the Business Source License included
#   in the file licenses/BSL-Couchbase.txt.  As of the Change Date specified
#   in that file, in accordance with the Business Source License, use of this
#   software will be governed by the Apache License, Version 2.0, included in
#   the file licenses/APL2.txt.
#

"""Parses a memcached log file for 'Slow op' warnings, and converts
into a Google Trace Event Format file
(https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview#heading=h.yr4qxyxotyw).

Usage:
    cat memcached.log | kv_slow_ops_2_gtrace > trace.json
    <open Chrome -> chrome://tracing -> Load 'trace.json'
"""

import fileinput
import json
import re

print('[')
first = True
node = ""
for line in fileinput.input():
    # Check if we're parsing logs from multiple nodes, extracting data for rebasing timestamps if we are.
    #
    # Match strings beginning with a cbcollect filepath, such as:
    # cbcollect_info_ns_1@ip-or-hostname_20220722-111444/memcached.log:[log line from file...]
    # and capture ip-or-hostname to uniquely identify each node.
    if node or first:
        m = re.search("^cbcollect_.*@(.+?)_.*", line)
        if m:
            node = m.group(1)
    # Match ISO 8601 formatted log timestamps. Example:
    # 2022-07-20T01:58:01.316016+03:00
    time_regex = "(\d{4}-\d{2}-\d{2}T[0-9:.+-]+)"
    m = re.search(time_regex + " WARNING (\d+): Slow operation. (.*)", line)
    if m:
        time = m.group(1)
        fd = m.group(2)
        slow_op = json.loads(m.group(3))

        # Set the common fields for all events for this operation
        common = dict()
        common['cat'] = slow_op['command']
        common['ph'] = 'X'
        # cid = "connectionID/opaque"
        cid = slow_op['cid']
        (connection_id, opaque) = cid.rsplit('/', 1)
        common['pid'] = connection_id

        # Build a trace event from each span in the slow op.
        for span in slow_op['trace'].split():
            (name, value) = span.split('=')
            (start_us, dur) = map(int, value.split(':'))
            # MB-43617: Ignore any spans which have zero time and duration;
            # they are spurious due to missing copy-elision when recording
            # Spans.
            if not (start_us or dur):
                continue
            event = dict()
            event.update(common)
            event['name'] = name
            event['ts'] = start_us / 1000
            event['dur'] = dur
            # For the top-level 'request' event, include additional request
            # details (redundant to repeat for every event).
            if name == 'request':
                event['args'] = {'opaque': opaque,
                                 'fd': fd,
                                 'peer': slow_op['peer']}
                event['args']['key'] = slow_op['packet']['key']
                event['args']['vbucket'] = slow_op['packet']['vbucket']
                event['args']['time'] = time
            if node:
                if 'args' not in event:
                    event['args'] = dict()
                event['args']['node'] = node
            if not first:
                print(',', end=' ')
            first = False
            print(json.dumps(event))
print(']')
