#!/usr/bin/env python3

#   Copyright 2018-Present Couchbase, Inc.
#
#   Use of this software is governed by the Business Source License included
#   in the file licenses/BSL-Couchbase.txt.  As of the Change Date specified
#   in that file, in accordance with the Business Source License, use of this
#   software will be governed by the Apache License, Version 2.0, included in
#   the file licenses/APL2.txt.
#

"""Parses a memcached log file for 'Slow op' warnings, and converts
into a Google Trace Event Format file
(https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview#heading=h.yr4qxyxotyw).

Usage:
    cat memcached.log | kv_slow_ops_2_gtrace > trace.json
    <open Chrome -> chrome://tracing -> Load 'trace.json'
"""

import fileinput
import json
import re
import unittest

def parse_slow_op(trace):
    """
    Parse the trace JSON from the slow operation log.
    """

    # In some cases, we might have improperly encoded values in the output.
    # These values are JSON objects wrapped in quotes, but the strings inside
    # the objects are unescaped and cause deserialisation to fail.

    # The cid object with IPv4
    trace = re.sub('"{"ip":"([\d\.]+)","port":(\d+)}\/(\w+)"',
                   '"\\1:\\2/\\3"', trace)
    # The cid object with IPv6
    trace = re.sub('"{"ip":"([0-9a-fA-F\.:]+)","port":(\d+)}\/(\w+)"',
                   '"[\\1]:\\2/\\3"', trace)
    # Peer object with IPv4
    trace = re.sub('"{"ip":"([\d\.]+)","port":(\d+)}"',
                   '"\\1:\\2"', trace)
    # Peer object with IPv6
    trace = re.sub('"{"ip":"([0-9a-fA-F\.:]+)","port":(\d+)}"',
                   '"[\\1]:\\2"', trace)

    return json.loads(trace)

class TestParsing(unittest.TestCase):

    def test_6_6_2(self):
        test_string = (
            r'{"cid":"7E/FF/20","duration":"11 s","trace":"request=63:11 '
            r'get=0:0 bg.wait=6308229496700500:55 get=6308229496693730:41 '
            r'bg.load=6308229496755836:11232001 get=0:0 get=630824072879295:11"'
            r',"command":"GET","peer":"{"ip":"0.0.0.0","port":57324}","bucket":'
            r'"b","packet":{"bodylen":49,"cas":0,"datatype":"raw","extlen":0,"'
            r'key":"<ud>c0ca65a1438baaab6c8a156b05d3b08d91bfacd7</ud>",'
            r'"keylen":49,"magic":"ClientRequest","opaque":513417216,'
            r'"opcode":"GET","vbucket":318}}'
        )
        obj = parse_slow_op(test_string)
        self.assertTrue(obj['cid'] == '7E/FF/20')
        self.assertTrue(obj['peer'] == '0.0.0.0:57324')

    def test_6_6_5(self):
        test_string = (
            r'{"cid":"{"ip":"0.0.0.0","port":42678}/ef","duration":"521 ms",'
            r'"trace":"request=6070831171407831:521890","command":"STAT",'
            r'"peer":"{"ip":"0.0.0.0","port":42678}","bucket":"a","packet":'
            r'{"bodylen":3,"cas":0,"datatype":"raw","extlen":0,"key":'
            r'"<ud>dcp</ud>","keylen":3,"magic":"ClientRequest",'
            r'"opaque":3724742144,"opcode":"STAT","vbucket":0}}'
        )
        obj = parse_slow_op(test_string)
        self.assertTrue(obj['cid'] == '0.0.0.0:42678/ef')
        self.assertTrue(obj['peer'] == '0.0.0.0:42678')

    def test_6_6_5_IPv6(self):
        test_string = (
            r'{"cid":"{"ip":"684D:1111:222:3333:4444:5555:6:77","port":'
            r'42678}/ef","duration":"521 ms","trace":'
            r'"request=6070831171407831:521890","command":"STAT","peer":"{"ip":'
            r'"684D:1111:222:3333:4444:5555:6:77","port":42678}","bucket":"a",'
            r'"packet":{"bodylen":3,"cas":0,"datatype":"raw","extlen":0,"key":'
            r'"<ud>dcp</ud>","keylen":3,"magic":"ClientRequest",'
            r'"opaque":3724742144,"opcode":"STAT","vbucket":0}}'
        )
        obj = parse_slow_op(test_string)
        print(obj)
        self.assertTrue(obj['cid'] ==
            '[684D:1111:222:3333:4444:5555:6:77]:42678/ef')
        self.assertTrue(obj['peer'] ==
            '[684D:1111:222:3333:4444:5555:6:77]:42678')

    def test_7_2_0(self):
        test_string = (
            r'{"bucket":"c","cid":"AF12/4FC/6c","command":"GET_CLUSTER_CONFIG",'
            r'"connection":"[ {\"ip\":\"0.0.0.0\",\"port\":54300} - '
            r'{\"ip\":\"0.0.0.0\",\"port\":11207} (<ud>dfs</ud>) ]","duration":'
            r'"580 ms","packet":{"bodylen":0,"cas":0,"datatype":"raw",'
            r'"extlen":0,"key":"<ud></ud>","keylen":0,"magic":"ClientRequest",'
            r'"opaque":693831680,"opcode":"GET_CLUSTER_CONFIG","vbucket":0},'
            r'"peer":{"ip":"0.0.0.0","port":54300},"response":"Success",'
            r'"trace":"request=10811483103351:580237 execute=108120633258:15",'
            r'"worker_tid":281472829188416}'
        )
        obj = parse_slow_op(test_string)
        self.assertTrue(obj['cid'] == 'AF12/4FC/6c')
        self.assertTrue(obj['peer']['ip'] == '0.0.0.0')
        self.assertTrue(obj['peer']['port'] == 54300)

def main():
    print('[')
    first = True
    node = ""
    for line in fileinput.input():
        # Check if we're parsing logs from multiple nodes, extracting data for rebasing timestamps if we are.
        #
        # Match strings beginning with a cbcollect filepath, such as:
        # cbcollect_info_ns_1@ip-or-hostname_20220722-111444/memcached.log:[log line from file...]
        # and capture ip-or-hostname to uniquely identify each node.
        if node or first:
            m = re.search("^cbcollect_.*@(.+?)_.*", line)
            if m:
                node = m.group(1)
        # Match ISO 8601 formatted log timestamps. Example:
        # 2022-07-20T01:58:01.316016+03:00
        time_regex = "(\d{4}-\d{2}-\d{2}T[0-9:.+-]+)"
        m = re.search(time_regex + " WARNING (\d+): Slow operation. (.*)", line)
        if m:
            time = m.group(1)
            fd = m.group(2)
            slow_op = parse_slow_op(m.group(3))

            # Set the common fields for all events for this operation
            common = dict()
            common['cat'] = slow_op['command']
            common['ph'] = 'X'
            # clientID "should" be a tuple of "connectionID/opaque", but
            # not all clients obey this convention.
            # As such, we extract the opaque here "just in case" - as older
            # server releases didn't report the full request packet, but if we
            # do have packet.opaque then use that in preference.
            cid = slow_op['cid']
            (connection_id, opaque) = cid.rsplit('/', 1)
            opaque = int(opaque, 16)
            if 'opaque' in slow_op['packet']:
                opaque = slow_op['packet']['opaque']
            common['pid'] = connection_id

            # Build a trace event from each span in the slow op.
            for span in slow_op['trace'].split():
                (name, value) = span.split('=')
                (start_us, dur) = map(int, value.split(':'))
                # MB-43617: Ignore any spans which have zero time and duration;
                # they are spurious due to missing copy-elision when recording
                # Spans.
                if not (start_us or dur):
                    continue
                event = dict()
                event.update(common)
                event['name'] = name
                event['ts'] = start_us / 1000
                event['dur'] = dur
                # For the top-level 'request' event, include additional request
                # details (redundant to repeat for every event).
                if name == 'request':
                    event['args'] = {'opaque': opaque,
                                    'fd': fd,
                                    'peer': slow_op['peer']}
                    event['args']['key'] = slow_op['packet']['key']
                    event['args']['vbucket'] = slow_op['packet']['vbucket']
                    event['args']['time'] = time
                if node:
                    if 'args' not in event:
                        event['args'] = dict()
                    event['args']['node'] = node
                if not first:
                    print(',', end=' ')
                first = False
                print(json.dumps(event))
    print(']')

if __name__ == '__main__':
    import os
    if os.environ.get('UNITTEST', '') == '1':
        unittest.main()
    else:
        main()
