{
    "params": {
        "allow_sanitize_value_in_deletion" : {
            "default" : "true",
            "descr": "Let EPE delete/prepare/del_with_meta prune any invalid body in the payload instead of failing",
            "dynamic" : true,
            "type" : "bool"
        },
        "alog_block_size": {
            "default": "4096",
            "descr": "Logging block size.",
            "dynamic": false,
            "type": "size_t",
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "alog_path": {
            "default": "",
            "descr": "Path to the access log.",
            "dynamic": true,
            "type": "std::string",
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "access_scanner_enabled": {
            "default": "true",
            "descr": "True if access scanner task is enabled",
            "dynamic": true,
            "type": "bool",
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "alog_sleep_time": {
            "default": "1440",
            "descr": "Number of minutes between each sweep for the access log",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 4320,
                    "min": 1
                }
            },
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "alog_task_time": {
            "default": "2",
            "descr": "Hour in GMT time when access scanner task is scheduled to run",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 23,
                    "min": 0
                }
            },
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "alog_resident_ratio_threshold": {
            "default": "95",
            "desr": "Resident ratio percentage above which we do not generate access log",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100,
                    "min": 0
                }
            },
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "alog_max_stored_items": {
            "default": "1024",
            "desr": "The maximum number of items the Access Scanner will hold in memory before commiting them to disk",
            "type": "size_t",
            "dynamic": true,
            "validator": {
                "range": {
                    "min": 1
                }
            },
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "backend": {
            "default": "couchdb",
            "desr": "The storage backend to use. The \"nexus\" variant is a test only backend which will run two backends for a single bucket and compare the results of their operations.",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "couchdb",
                    "magma",
                    "rocksdb",
                    "nexus"
                ]
            }
        },
        "backfill_mem_threshold": {
            "default": "96",
            "desr": "Memory usage threshold (percentage of bucket quota) after which backfill will be snoozed.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100,
                    "min": 0
                }
            }
        },
        "bfilter_enabled": {
            "default": "true",
            "desr": "Enable or disable the bloom filter",
            "dynamic": true,
            "type": "bool"
        },
        "bfilter_key_count": {
            "default": "10000",
            "desr": "Bloomfilter: Estimated key count per vbucket",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 1
                }
            }
        },
        "bfilter_fp_prob": {
            "default": "0.01",
            "desr": "Bloomfilter: Allowed probability for false positives",
            "dynamic": true,
            "type": "float"
        },
        "bfilter_residency_threshold": {
            "default": "0.1",
            "desr" : "If resident ratio (during full eviction) were found less than this threshold, compaction will include all items into bloomfilter",
            "dynamic": true,
            "type" : "float",
            "validator": {
                "range": {
                    "max": 1.0,
                    "min": 0.0
                }
            }
        },
        "bucket_type": {
            "default": "persistent",
            "descr": "Bucket type in the couchbase server",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                         "ephemeral",
                         "persistent"
                        ]
            }
        },
        "compaction_expire_from_start": {
            "default": "true",
            "descr": "Should compaction expire items that were logically deleted at the start of the compaction (true) or at the point in time at which they were visited (false)?",
            "dynamic": true,
            "type": "bool"
        },
        "chk_expel_enabled": {
            "default" : "true",
            "descr": "Enable the ability to expel (remove from memory) items from a checkpoint.  An item can be expelled if all cursors in the checkpoint have iterated past the item.",
            "dynamic" : true,
            "type": "bool"
        },
        "chk_max_items": {
            "default": "10000",
            "descr": "Max number of (non-meta) items in each checkpoint.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 1,
                    "max": 100000
                }
            }
        },
        "chk_period": {
            "default": "5",
            "descr": "Age of the open checkpoint (in seconds) that may trigger checkpoint creation.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 1,
                    "max": 86400
                }
            }
        },
        "chk_remover_stime": {
            "default": "5",
            "dynamic": false,
            "type": "size_t"
        },
        "checkpoint_destruction_tasks": {
            "default": "1",
            "descr": "Number of tasks responsible for destroying closed unreferenced checkpoints.",
            "dynamic": false,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 1
                }
            }
        },
        "checkpoint_memory_ratio": {
            "default": "0.3",
            "descr": "Max ratio of the bucket quota that can be allocated in checkpoints. The system enters a TempOOM phase if hit.",
            "dynamic": true,
            "type": "float",
            "validator": {
                "range": {
                    "min": 0.0,
                    "max": 1.0
                }
            }
        },
        "checkpoint_memory_recovery_upper_mark": {
            "default": "0.9",
            "descr": "Fraction of the checkpoint quota (as computed by checkpoint_memory_ratio) that triggers attempt of memory releasing from checkpoint.",
            "dynamic": true,
            "type": "float",
            "validator": {
                "range": {
                    "min": 0.0,
                    "max": 1.0
                }
            }
        },
        "checkpoint_memory_recovery_lower_mark": {
            "default": "0.6",
            "descr": "Fraction of the checkpoint quota (as computed by checkpoint_memory_ratio) that represents the target of checkpoint memory recovery. Memory recovery yields when reached.",
            "dynamic": true,
            "type": "float",
            "validator": {
                "range": {
                    "min": 0.0,
                    "max": 1.0
                }
            }
        },
        "checkpoint_remover_task_count": {
            "default": "1",
            "descr": "Number of concurrent tasks performing ItemExpel and CursorDrop/CheckpointRemoval",
            "dynamic": false,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 1
                }
            }
        },
        "checkpoint_max_size": {
            "default": "0",
            "descr": "Max size (in bytes) of a single checkpoint. '0' for EPEngine auto-setup.",
            "dynamic": true,
            "type": "size_t"
        },
        "collections_drop_compaction_delay" : {
            "default": "5000",
            "descr": "How many milliseconds before compaction runs following the drop of a collection",
            "dynamic": false,
            "type": "size_t"
        },
        "collections_enabled" : {
            "default": "true",
            "descr": "Enable the collections functionality, enabling the storage of collection metadata",
            "dynamic": false,
            "type": "bool"
        },
        "compression_mode": {
            "default": "off",
            "descr": "Determines which compression mode the bucket operates in",
	    "dynamic": true,
            "type": "std::string",
            "validator": {
                "enum": [
                         "off",
                         "passive",
                         "active"
                        ]
            }
        },
        "compaction_write_queue_cap": {
            "default": "10000",
            "desr" : "Disk write queue threshold after which compaction tasks will be made to snooze, if there are already pending compaction tasks",
	    "dynamic": true,
            "type" : "size_t",
            "validator": {
                "range": {
                    "min": 1
                }
            }
        },
        "compaction_max_concurrent_ratio": {
            "default": "0.5",
            "desr" : "Maximum number of CompactVBucketTask tasks which can run concurrently, as a fraction of the possible Writer task concurrency. Note that a minimum of 1, and a maximum of N-1 CompactVBucketTasks will be run (where N is the possible Writer task concurrency), to ensure both forward progress for Compaction and Flushing.",
            "dynamic": true,
            "type" : "float",
            "validator": {
                "range": {
                    "min": 0.0,
                    "max": 1.0
                }
            }
        },
        "concurrent_pagers": {
            "default": "2",
            "descr": "Number of eviction pager tasks to create when memory usage is high",
            "dynamic": false,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 1
                }
            }
        },
        "expiry_pager_concurrency": {
            "default": "2",
            "descr": "Number of tasks which are created to scan for and delete expired items",
            "dynamic": false,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 1,
                    "max": 128
                }
            }
        },
        "conflict_resolution_type": {
            "default": "seqno",
            "desr": "Conflict resolution mode to use for this Bucket",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "seqno",
                    "lww",
                    "custom"
                ]
            }
        },
        "couch_bucket": {
            "default": "default",
            "descr": "The name of this bucket",
            "dynamic": false,
            "type": "std::string"
        },
        "data_traffic_enabled": {
            "default": "true",
            "descr": "True if we want to enable data traffic after warmup is complete",
            "dynamic": false,
            "type": "bool"
        },
        "dbname": {
            "default": "",
            "descr": "Path to on-disk storage.",
            "dynamic": false,
            "type": "std::string"
        },
        "dcp_consumer_control_enabled" : {
            "default": "false",
            "descr": "When true, a DcpConsumer can accept control messages. This is intended to be used by tests.",
            "dynamic": false,
            "type": "bool"
        },
        "dcp_noop_mandatory_for_v5_features": {
            "default": "true",
            "descr": "Forces clients to enable noop for v5 features",
            "dynamic": true,
            "type": "bool"
        },
        "defragmenter_enabled": {
            "default": "true",
            "descr": "True if defragmenter task is enabled",
            "dynamic": true,
            "type": "bool"
        },
        "defragmenter_interval": {
            "default": "10.0",
            "descr": "How often defragmenter task should be run (in seconds).",
            "dynamic": true,
            "type": "float"
        },
        "defragmenter_age_threshold": {
            "default": "10",
            "descr": "How old (measured in number of DefragmenterVisitor passes) must a document be to be considered for defragmentation.",
            "type": "size_t",
            "dynamic" : true
        },
        "defragmenter_stored_value_age_threshold": {
            "default": "10",
            "descr": "How old (measured in number of DefragmenterVisitor passes) must a StoredValue be to be considered for defragmentation.",
            "type": "size_t",
            "dynamic" : true
        },
        "defragmenter_chunk_duration": {
            "default": "20",
            "descr": "Maximum time (in ms) defragmentation task will run for before being paused (and resumed at the next defragmenter_interval).",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 1
                }
            }
        },
        "defragmenter_mode" : {
            "default": "auto_pid",
            "descr": "Determines how the defragmenter controls its sleep interval. When static defragmenter_interval is used. When auto_linear, scale the sleep time using a scored defragmentation when it falls between defragmenter_auto_lower_trigger and defragmenter_auto_upper_trigger. When auto_pid use a PID controller to computer reductions in the sleep interval when scored fragmentation is above defragmenter_auto_lower_trigger.",
            "dynamic": true,
            "type": "std::string",
            "validator": {
                "enum": [
                    "static",
                    "auto_linear",
                    "auto_pid"
                ]
            }
        },
        "defragmenter_auto_lower_threshold" : {
            "default": "0.07",
            "descr": "When mode is not static and scored fragmentation is above this value, a sleep time between defragmenter_auto_min_sleep and defragmenter_auto_max_sleep will be used",
            "dynamic": true,
            "type": "float"
        },
        "defragmenter_auto_upper_threshold" : {
            "default": "0.25",
            "descr": "When mode is auto_linear and scored fragmentation is above this value, the defragmenter will use defragmenter_auto_min_sleep",
            "dynamic": true,
            "type": "float"
        },
        "defragmenter_auto_max_sleep" : {
            "default": "10.0",
            "descr": "The maximum sleep that the auto controller can set",
            "dynamic": true,
            "type": "float"
        },
        "defragmenter_auto_min_sleep" : {
            "default": "0.6",
            "descr": "The minimum sleep that the auto controller can set",
            "dynamic": true,
            "type": "float"
        },
        "defragmenter_auto_pid_p" : {
            "default": "0.3",
            "descr": "The p term for the PID controller",
            "dynamic": true,
            "type": "float"
        },
        "defragmenter_auto_pid_i" : {
            "default": "0.0000197",
            "descr": "The i term for the PID controller",
            "dynamic": true,
            "type": "float"
        },
        "defragmenter_auto_pid_d" : {
            "default": "0.0",
            "descr": "The d term for the PID controller",
            "dynamic": true,
            "type": "float"
        },
        "defragmenter_auto_pid_dt" : {
            "default": "30000",
            "descr": "The dt (interval) term for the PID controller. Value represents milliseconds",
            "dynamic": true,
            "type": "size_t"
        },
        "durability_timeout_mode": {
            "default": "event-driven",
            "descr": "How should durability timeouts be scheduled? polling=periodic task running every 'durability_timeout_task_interval'; event-driven=per-VBucket tasks scheduled based on when next SyncWrite will time out.",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "polling",
                    "event-driven"
                ]
            }
        },
        "durability_timeout_task_interval": {
            "default": "25",
            "descr": "Interval (in ms) between subsequent runs of the DurabilityTimeoutTask",
            "dynamic": true,
            "type": "size_t",
            "requires": {
                "durability_timeout_mode": "polling"
            }

        },
        "durability_min_level": {
            "default": "none",
            "descr": "Bucket Minimum Durability Level. KVEngine upgrades any write request to this min-level, if the min-level is higher than the write-level. May upgrade a NormalWrite to SyncWrite.",
            "dynamic": true,
            "type": "std::string",
            "validator": {
                "enum": [
                    "none",
                    "majority",
                    "majority_and_persist_on_master",
                    "persist_to_majority"
                ]
            }
        },
        "ephemeral_full_policy": {
            "default": "auto_delete",
            "descr": "How should an Ephemeral bucket becoming full be handled?",
            "dynamic": true,
            "type": "std::string",
            "validator": {
                "enum": [
                    "auto_delete",
                    "fail_new_data"
                ]
            },
            "requires": {
                "bucket_type": "ephemeral"
            }
        },
        "ephemeral_metadata_purge_age": {
            "default": "60",
            "descr": "Age in seconds after which Ephemeral metadata is purged entirely from memory. Purging disabled if set to -1.",
            "dynamic": true,
            "type": "ssize_t",
            "requires": {
                "bucket_type": "ephemeral"
            }
        },
        "ephemeral_metadata_purge_interval": {
            "default": "60",
            "descr": "Time in seconds between automatic, periodic runs of the Ephemeral metadata purge task. Periodic purging disabled if set to 0.",
            "dynamic": true,
            "type": "size_t",
            "requires": {
                "bucket_type": "ephemeral"
            }
        },
        "ephemeral_metadata_mark_stale_chunk_duration": {
            "default": "20",
            "descr": "Maximum time (in ms) ephemeral hash table cleaner task will run for before being paused (and resumed at the next ephemeral_metadata_purge_interval).",
            "dynamic": true,
            "type": "size_t",
            "requires": {
                "bucket_type": "ephemeral"
            }
        },
        "ephemeral_metadata_purge_stale_chunk_duration": {
            "default": "20",
            "descr": "Maximum time (in ms) ephemeral stale metadata purge task will run for before being paused (and resumed at the next ephemeral_metadata_purge_interval).",
            "dynamic": true,
            "type": "size_t",
            "requires": {
                "bucket_type": "ephemeral"
            }
        },
        "executor_pool_backend": {
            "default": "folly",
            "descr": "Executor Pool backend in use",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "cb3",
                    "folly"
                ]
            }
        },
        "exp_pager_enabled": {
            "default": "true",
            "descr": "True if expiry pager task is enabled",
            "dynamic": true,
            "type": "bool"
        },
        "exp_pager_stime": {
            "default": "600",
            "descr": "Number of seconds between expiry pager runs.",
            "dynamic": true,
            "type": "size_t"
        },
        "exp_pager_initial_run_time": {
            "default": "-1",
            "descr": "Hour in GMT time when expiry pager can be scheduled for initial run",
            "dynamic": true,
            "type": "ssize_t",
            "validator": {
                "range": {
                    "max": 23,
                    "min": -1
                }
            }
        },
        "failpartialwarmup": {
            "default": "true",
            "descr": "If true then do not allow traffic to be enabled to the bucket if warmup didn't complete successfully",
            "dynamic": false,
            "type": "bool"
        },
        "flusher_total_batch_limit" : {
            "default": "4000000",
            "descr": "Number of items that all flushers can be currently flushing. Each flusher has flusher_total_batch_limit / num_writer_threads individual batch size. Individual batches may be larger than this value, as we cannot split Memory checkpoints across multiple commits.",
            "dynamic": true,
            "type": "size_t"
        },
        "getl_default_timeout": {
            "default": "15",
            "descr": "The default timeout for a getl lock in (s)",
            "dynamic": true,
            "type": "size_t"
        },
        "getl_max_timeout": {
            "default": "30",
            "descr": "The maximum timeout for a getl lock in (s)",
            "dynamic": true,
            "type": "size_t"
        },
        "hlc_drift_ahead_threshold_us": {
            "default": "5000000",
            "descr": "The μs threshold of drift at which we will increment a vbucket's ahead counter.",
            "dynamic": true,
            "type": "size_t"
        },
        "hlc_drift_behind_threshold_us": {
            "default": "5000000",
            "descr": "The μs threshold of drift at which we will increment a vbucket's behind counter.",
            "dynamic": true,
            "type": "size_t"
        },
        "ht_locks": {
            "default": "47",
            "dynamic": false,
            "type": "size_t"
        },
        "ht_resize_interval": {
            "default": "1",
            "descr": "Interval in seconds to wait between HashtableResizerTask executions.",
            "dynamic": true,
            "type": "size_t"
        },
        "ht_size": {
            "default": "47",
            "descr": "Initial number of slots in HashTable objects.",
            "dynamic": false,
            "type": "size_t"
        },
        "item_compressor_interval": {
            "default": "250",
            "descr": "How often the item compressor task should run (in milliseconds)",
            "dynamic": true,
            "type": "size_t"
        },
        "item_compressor_chunk_duration": {
            "default": "20",
            "descr": "Maximum time (in ms) item compression task will run for before being paused (and resumed at the next item_compressor_interval).",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 1
                }
            }
        },
        "item_eviction_policy": {
            "default": "value_only",
            "descr": "Item eviction policy on cache, which is used by the item pager",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "value_only",
                    "full_eviction"
                ]
            },
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "item_eviction_age_percentage": {
            "default": "30",
            "descr": "The age percentage used when determining the age threshold in the hifi_mfu eviction policy.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 0,
                    "max": 100
                }
            }
        },
        "item_eviction_freq_counter_age_threshold": {
            "default": "1",
            "decr": "The threshold for determining at what execution frequency we consider age when selecting items for eviction.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 0,
                    "max": 255
                }
            }
        },
        "item_freq_decayer_chunk_duration": {
            "default": "20",
            "descr": "Maximum time (in ms) itemFreqDecayer task will run for before being paused.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 1
                }
            }
        },
        "item_freq_decayer_percent": {
            "default": "50",
            "descr": "The percent that the frequency counter of a document is decayed when visited by item_freq_decayer.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 0,
                    "max": 100
                }
            }
        },
        "item_num_based_new_chk": {
            "default": "true",
            "descr": "True if the number of items in the current checkpoint plays a role in a new checkpoint creation",
            "dynamic": true,
            "type": "bool"
        },
        "connection_manager_interval": {
            "default": "1",
            "descr": "How often connection manager task should be run (in seconds).",
            "type": "size_t",
            "dynamic": true,
            "validator": {
                "range": {
                    "min": 1
                }
            }
        },
        "max_checkpoints": {
            "default": "10",
            "descr": "Max number of checkpoints in each VBucket.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 2
                }
            }
        },
        "max_failover_entries": {
            "default": "25",
            "descr": "maximum number of failover log entries",
            "dynamic": false,
            "type": "size_t"
        },
        "max_item_privileged_bytes": {
            "default": "(1024 * 1024)",
            "descr": "Maximum number of bytes allowed for 'privileged' (system) data for an item in addition to the max_item_size bytes",
            "dynamic": true,
            "type": "size_t"
        },
        "max_item_size": {
            "default": "(20 * 1024 * 1024)",
            "descr": "Maximum number of bytes allowed for an item",
            "dynamic": true,
            "type": "size_t"
        },
        "max_size": {
            "default": "(100 * 1024 * 1024)",
            "dynamic": true,
            "type": "size_t",
            "descr": "Memory quota (in bytes) for this bucket.",
            "aliases":["cache_size"]
        },
        "max_ttl":{
            "default": "0",
            "descr": "A maximum TTL (in seconds) that will apply to all new documents, documents set with no TTL will be given this value. A value of 0 means this is disabled",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 0,
                    "max": 2147483647
                }
            }
        },
        "max_vbuckets": {
            "default": "1024",
            "descr": "Maximum number of vbuckets expected",
            "dynamic": false,
            "type": "size_t"
        },
        "max_threads": {
            "default": "0",
            "descr": "Maximum number of threads of any single class (0 = automatically select based on core count)",
            "dynamic": false,
            "type": "size_t"
        },
        "max_num_bgfetchers": {
            "default": "0",
            "descr": "Maximum number of bg fetcher objects (the number of concurrent bg fetch tasks we can run). 0 = auto-configure which means we use the same number as the number of shards (max_num_shards - for historic reasons). See also num_reader_threads.",
            "dynamic": false,
            "type": "size_t"
        },
        "max_num_flushers": {
            "default": "0",
            "descr": "Maximum number of flusher objects (the number of concurrent flusher tasks we can run). 0 = auto-configure which means we use the same number as the number of shards (max_num_shards - for historic reasons). See also num_writer_threads.",
            "dynamic": false,
            "type": "size_t"
        },
        "max_num_shards": {
            "default": "0",
            "descr": "Maximum mumber of shards (0 = auto-configure)",
            "dynamic": false,
            "type": "size_t"
        },
        "max_num_workers": {
            "default": "4",
            "descr": "Bucket Priority relative to other buckets",
            "dynamic": false,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 8,
                    "min": 1
                }
            }
        },
        "mem_used_merge_threshold_percent" : {
            "default": "0.5",
            "descr": "What percent of max_data size should we allow the estimated total memory to lag by (EPStats::getEstimatedTotalMemoryUsed)",
            "dynamic": true,
            "type": "float",
            "validator": {
                "range": {
                    "max": 100.0,
                    "min": 0.0
                }
            }
        },
        "nexus_primary_backend": {
            "default": "couchdb",
            "descr": "If using the Nexus testing backend then this configuration parameter specifies which type of KVStore to create as the primary variant.",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "couchdb",
                    "magma",
                    "rocksdb"
                ]
            },
            "requires": {
                "backend": "nexus"
            }
        },
        "nexus_secondary_backend": {
            "default": "magma",
            "descr": "If using the Nexus testing backend then this configuration parameter specifies which type of KVStore to create as the secondary variant.",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "couchdb",
                    "magma",
                    "rocksdb"
                ]
            },
            "requires": {
                "backend": "nexus"
            }
        },
        "nexus_error_handling": {
            "default": "throw",
            "descr": "If using the Nexus testing backend then this config parameter specifies how errors (discrepancies) between the primary and secondary backends are handled.",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "abort",
                    "log",
                    "throw"
                ]
            },
            "requires": {
                "backend": "nexus"
            }
        },
        "nexus_implicit_compaction_enabled": {
            "default": "true",
            "descr": "Should NexusKVStore enable implicit compaction?",
            "dynamic": false,
            "type": "bool",
            "requires": {
                "backend": "nexus"
            }
        },
        "nexus_concurrent_flush_compaction_enabled": {
            "default": "true",
            "descr": "Should NexusKVStore enable concurrent flushing and compaction?",
            "dynamic": false,
            "type": "bool",
            "requires": {
                "backend": "nexus"
            }
        },
        "num_reader_threads": {
            "default": "0",
            "descr": "Number of reader threads (0 = Default, -1 = Disk IO Optimized)",
            "dynamic": true,
            "type": "ssize_t",
            "validator": {
                "range": {
                    "max": 512,
                    "min": -1
                }
            }
        },
        "num_writer_threads": {
            "default": "0",
            "descr": "Number of writer threads (0 = Default, -1 = Disk IO Optimized)",
            "dynamic": true,
            "type": "ssize_t",
            "validator": {
                "range": {
                    "max": 512,
                    "min": -1
                }
            }
        },
        "num_auxio_threads": {
            "default": "0",
            "descr": "Throttle max number of aux io threads (0 = Default, auto-configured based on CPU core count)",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 512,
                    "min": 0
                }
            }
        },
        "num_nonio_threads": {
            "default": "0",
            "descr": "Throttle max number of non io threads (0 = Default, auto-configured based on CPU core count)",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 512,
                    "min": 0
                }
            }
        },
        "mem_high_wat": {
            "default": "max",
            "dynamic": true,
            "type": "size_t"
        },
        "mem_low_wat": {
            "default": "max",
            "dynamic": true,
            "type": "size_t"
        },
        "mutation_mem_threshold": {
            "default": "93",
            "desr": "Percentage of memory that can be used before mutations return tmpOOMs",
            "dynamic": true,
            "type": "size_t",
            "validator" : {
                "range" : {
                    "max": 100,
                    "min": 0
                }
            }
        },
        "pager_active_vb_pcnt": {
            "default": "40",
            "descr": "Active vbuckets paging percentage",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 50,
                    "min": 0
                }
            }
        },
        "pager_sleep_time_ms": {
            "default": "5000",
            "descr": "How long in milliseconds the ItemPager will sleep for when not being requested to run",
            "dynamic": true,
            "type": "size_t"
        },
        "persistent_metadata_purge_age": {
            "default": "259200",
            "descr": "Age in seconds after which tombstones may be purged. Defaults to 3 days. Max of 60 days. If this is dynamically changed for a magma bucket then magma may not trigger compactions when it should, this can be avoided by running a full manual compaction after changing this parameter.",
            "dynamic": true,
            "type": "size_t",
            "requires": {
                "bucket_type": "persistent"
            },
            "validator": {
                "range": {
                    "max": 5184000,
                    "min": 60
                }
            }
        },
        "pitr_enabled" : {
            "default": "false",
            "descr": "Is PiTR enabled or not",
            "dynamic": true,
            "type": "bool"
        },
        "pitr_max_history_age": {
            "default":  "86400",
            "descr": "The number of seconds of the oldest entry to keep as part of compaction (up to 48 hours)",
            "dynamic" : true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 172800,
                    "min": 1
                }
            }
        },
        "pitr_granularity": {
            "default":  "600",
            "descr": "The granularity (interval between each rollback point) in seconds (up to 5 hours)",
            "dynamic" : true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 18000,
                    "min": 1
                }
            }
        },
        "replication_throttle_threshold": {
            "default": "99",
            "descr": "Percentage of max mem at which we begin NAKing replication input.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100,
                    "min": 0
                }
            }
        },
        "uuid": {
            "default": "",
            "descr": "The UUID for the bucket",
            "dynamic" : false,
            "type": "std::string"
        },
        "dcp_backfill_byte_limit": {
            "default": "20972856",
            "descr": "Max bytes a connection can backfill into memory before backfill is paused",
            "dynamic": false,
            "type": "size_t"
        },
        "dcp_flow_control_policy": {
            "default": "aggressive",
            "descr": "Flow control policy used on consumer side buffer",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                         "none",
                         "static",
                         "dynamic",
                         "aggressive"
                        ]
            }
        },
        "dcp_conn_buffer_size": {
            "default": "10485760",
            "descr": "Size in bytes of an dcp consumer connection buffer",
            "dynamic": true,
            "type": "size_t"
        },
        "dcp_conn_buffer_size_max": {
            "default": "52428800",
            "descr": "Max size in bytes of an dcp consumer connection buffer",
            "dynamic": true,
            "type": "size_t"
        },
        "dcp_conn_buffer_size_perc": {
            "default": "1",
            "descr": "Percentage of memQuota for a dcp consumer connection buffer in dynamic flow ctl policy",
            "type": "size_t",
            "dynamic": true,
            "validator": {
                "range": {
                    "max": 10,
                    "min": 1
                }
            }
        },
        "dcp_conn_buffer_size_aggr_mem_threshold": {
            "default": "10",
            "descr": "Aggr mem usage by all dcp conns (as percentage of memQuota) after which only dcp_conn_buffer_size is allocated",
            "type": "size_t",
            "dynamic": true,
            "validator": {
                "range": {
                    "max": 20,
                    "min": 1
                }
            }
        },
        "dcp_conn_buffer_size_aggressive_perc": {
            "default": "5",
            "descr": "Percentage of memQuota for all dcp consumer connection buffers in aggressive flow ctl policy",
            "type": "size_t",
            "dynamic": true,
            "validator": {
                "range": {
                    "max": 20,
                    "min": 1
                }
            }
        },
        "dcp_enable_noop": {
            "default": "true",
            "descr": "Whether DCP Consumer connections should attempt to negotiate no-ops with the Producer",
            "dynamic": true,
            "type": "bool"
        },
        "dcp_min_compression_ratio": {
            "default": "0.85",
            "desr": "Compression ratio to be achieved above which producer will ship documents as is",
            "dynamic": true,
            "type": "float",
            "validator": {
                "range": {
                    "min": 0.0
                }
            }
        },
        "dcp_idle_timeout": {
            "default": "360",
            "descr": "The maximum number of seconds between dcp messages before a connection is disconnected",
            "dynamic": true,
            "type": "size_t"
        },
        "dcp_noop_tx_interval": {
            "default": "1",
            "descr": "The time interval in seconds between noop messages being sent to the consumer",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max" : 360,
                    "min" : 1
                }
            }
        },
        "dcp_scan_byte_limit": {
            "default": "4194304",
            "descr": "Max bytes that can be read in a single backfill scan before yielding",
            "dynamic": false,
            "type": "size_t"
        },
        "dcp_scan_item_limit": {
            "default": "4096",
            "descr": "Max items that can be read in a single backfill scan before yielding",
            "dynamic": false,
            "type": "size_t"
        },
        "dcp_takeover_max_time": {
            "default": "60",
            "descr": "Max amount of time for takeover send (in seconds) after which front end ops would return ETMPFAIL",
            "dynamic": true,
            "type": "size_t"
        },
        "dcp_producer_snapshot_marker_yield_limit": {
            "default": "10",
            "descr": "The number of snapshots before ActiveStreamCheckpointProcessorTask::run yields.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100000000,
                    "min": 1
                }
            }
        },
        "dcp_consumer_process_buffered_messages_yield_limit" : {
            "default": "10",
            "descr": "The number of processBufferedMessages iterations before forcing the task to yield.",
	        "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100000000,
                    "min": 1
                }
            }
        },
        "dcp_consumer_process_buffered_messages_batch_size" : {
            "default": "10",
            "descr": "The maximum number of items stream->processBufferedMessages will consume.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100000000,
                    "min": 1
                }
            }
        },
        "fsync_after_every_n_bytes_written": {
            "default": "1048576",
            "descr": "Perform a file sync() operation after every N bytes written. Disabled if set to 0.",
            "dynamic": true,
            "type" : "size_t"
        },
        "min_compression_ratio": {
            "default": "1.2",
            "descr": "specifies a minimum compression ratio below which storing the document will be stored as uncompressed.",
            "dynamic": true,
            "type" : "float",
            "validator": {
                "range": {
                    "min": 0.0
                }
            }
        },
        "magma_delete_memtable_writecache": {
            "default": "8192",
            "dynamic": false,
            "descr": "Magma uses a lazy update model to maintain the sequence index. It maintains a list of deleted seq #s that were deleted from the key Index.",
            "type": "size_t"
        },
        "magma_delete_frag_ratio": {
            "default": "0.50",
            "dynamic": false,
            "descr": "Magma compaction always removes duplicate keys but not all sstables are visited during compaction.. This is the minimum fragmentation ratio threshold for when a compaction will be triggerred.",
            "type": "float"
        },
        "magma_max_checkpoints": {
            "default": "5",
            "dynamic": false,
            "descr": "Maximum # of checkpoints retained for rollback.",
            "type": "size_t"
        },
        "magma_checkpoint_interval": {
            "default": "120",
            "dynamic": false,
            "descr": "Frequency of checkpoint interval; in seconds. A checkpoint provides a rollback point to which the data store can rollback to in the event of a failure.",
            "type": "size_t"
        },
        "magma_min_checkpoint_interval": {
            "default": "1",
            "dynamic": false,
            "descr": "Minimum interval between two checkpoints; in seconds. Prevents excessive creation of checkpoints.",
            "type": "size_t"
        },
        "magma_checkpoint_threshold": {
            "default": "0.02",
            "dynamic": false,
            "descr": "Threshold of data written before a checkpoint is created; threshold is based on a fraction of the total data size. Checkpoints require data to be retained in order to provide rollback capability. If the amount of data written during a checkpoint interval is large, we need to do more frequent checkpoints to reduce space amplification.",
            "type": "float"
        },
        "magma_heartbeat_interval": {
            "default": "10",
            "dynamic": false,
            "descr": "Frequency of heartbeat interval; in seconds. A heartbeat task is scheduled to provide cleanup and maintenance when magma is idle.",
            "type": "size_t"
        },
        "magma_value_separation_size": {
            "default": "32",
            "dynamic": false,
            "descr": "Values smaller than this will not be separated from their keys.",
            "type": "size_t"
        },
        "magma_write_cache_ratio": {
            "default": "0.2",
            "dynamic": false,
            "descr": "Memory is maintained across 3 magma components; Bloom filters, Block cache and Write cache. The least important of these is the write cache. If there is insufficent memory for the write cache, the write cache will grow to the size of the batch and then be immediately flushed and freed. If there is available memory, the write cache is limited to 20% of the available memory (after bloom filter and block cache get their memory up to magma_max_write_cache (128MB). Bloom filters are the most important and are never paged out. Bloom filter memory can cause magma to go above the memory quota. To allevaite this, the bottom layer where the majority of bloom filter memory is, won't use bloom filters when OptimizeBloomFilterForMisses is on (which it is by default). The block cache grows each time the index sizes change. But its growth is bounded by the available memory or what's left over after the bloom filter memory is subtracted.",
            "type": "float"
        },
        "magma_max_write_cache": {
            "default": "134217728",
            "dynamic": false,
            "descr": "Magma uses a common skiplist to buffer all items at the shard level called the write cache. The write cache contains items from all the kvstores that are part of the shard and when it is flushed, each kvstore will receive a few items each. Regardless of how much memory might be available, this would be the maximum amount that could be allocated.",
            "type": "size_t"
        },
        "magma_mem_quota_ratio": {
            "default": "0.5",
            "dynamic": true,
            "descr": "Magma total memory ratio of the Bucket Quota across all shards and Magma limit's it's memory usage to this value.",
            "type": "float"
        },
        "magma_mem_quota_low_watermark_ratio": {
            "default": "0.2",
            "dynamic": false,
            "descr": "Fraction of memory quota used by magma as it's low water mark. Magma uses this low watermark to size it's write cache and block cache. This sizing includes bloom filters memory usage but bloom filter eviction is based on the memory quota",
            "type": "float"
        },
        "magma_enable_direct_io": {
            "default": "false",
            "dynamic": false,
            "descr": "Using direct IO tells magma to bypass the file system cache when writing or reading sstables.",
            "type": "bool"
        },
        "magma_initial_wal_buffer_size": {
            "default": "65536",
            "dynamic": false,
            "descr": "The WAL buffer is used to stage items to the write ahead log along with control information like begin and end transaction. This parameter refers to the initial WAL buffer size. The WAL buffer will adjust its size up to a maximum of 4MB or down to a minimum of 64KB depending on the transaction batch size with consideration for other magma components which consume memory such as the block cache, bloom filters, write cache and meta data overhead.",
            "type": "size_t"
        },
        "magma_flusher_thread_percentage": {
            "default": "20",
            "dynamic": true,
            "descr": "Percentage of storage threads that are flusher threads (i.e. with a value of 20 we will allocate 4 (1/5th) of the storage threads to flushers and the remaining 16 (4/5ths) threads will be compactors).",
            "type": "size_t"
        },
        "magma_enable_group_commit": {
            "default": "false",
            "desr": "Group Commit allows transactions in magma to be grouped together to reduce the number of WAL fsyncs. When a transaction is ready to fsync, if there are new transactions waiting to start, we stall the transaction waiting to fsync until there are no more transactions waiting to start for a given magma instance.",
            "dynamic": false,
            "type": "bool"
        },
        "magma_group_commit_max_sync_wait_duration_ms": {
            "default": "20",
            "desr": "When a transaction is about to stall because there are pending transactions waiting to start, if there already are transactions waiting and the oldest transaction has been waiting for magma_group_commit_max_sync_wait_duration ms or more, the current transaction will perform the fsync. When group commit is enabled and both magma_group_commit_max_sync_wait_duration and magma_group_commit_max_transaction_count are set to 0, transactions will stall until there are no more transactions waiting to start. Unit is milliseconds.",
            "dynamic": false,
            "type": "size_t"
        },
        "magma_group_commit_max_transaction_count": {
            "default": "20",
            "desr": "When a transaction is about to stall because there are pending transactions waiting to start, if there already are magma_group_commit_max_transaction_count including the current transaction waiting, the current transaction will perform the fsync. When group commit is enabled and both magma_group_commit_max_sync_wait_duration and magma_group_commit_max_transaction_count are set to 0, transactions will stall until there are no more transactions waiting to start.",
            "dynamic": false,
            "type": "size_t"
        },
        "magma_max_default_storage_threads": {
            "default": "20",
            "dynamic": false,
            "descr": "If the number of storage threads = 0, then we set the number of storage threads based on the number of writer threads up to a maximum of 20 threads and use magma_flusher_thread_percentage to determine the ratio of flusher and compactor threads.",
            "type": "size_t"
        },
        "magma_sync_every_batch": {
            "default": "false",
            "dynamic": false,
            "descr": "Couchstore generates a commit point at the end of every batch of items. During normal operation, Magma checkpoints are taken at every magma_checkpoint_interval. Many of the tests require more frequent checkpoints so this configuration parameter makes sure every batch generates a checkpoint. Each checkpoint generated in this way is a \"Sync\" checkpoint and isn't going to be useful for rollback as it only the latest checkpoint is a \"Sync\" checkpoiont. A \"Rollback\" checkpoint will be made instead if we set magma_checkpoint_interval to 0. The \"Rollback\" checkpoints are stored in the checkpoint queue as potential rollback points. Should be used for testing only!",
            "type": "bool"
        },
        "magma_enable_wal": {
            "default": "true",
            "dynamic": false,
            "descr": "WAL ensures Magma's atomicity, durability. Disabling it is useful in performance analysis.",
            "type": "bool"
        },
        "magma_enable_upsert": {
            "default": "false",
            "dynamic": false,
            "descr": "When true, the kv_engine will utilize Magma's upsert capabiltiy but accurate document counts for the data store or collections can not be maintained.",
            "type": "bool"
        },
        "magma_expiry_purger_interval": {
            "default": "3600",
            "dynamic":false,
            "descr": "Magma maintains statistics about expired documents to run compaction based on magma_expiry_frag_threshold. This config determines the the expiry purger polling interval in seconds to trigger compaction on eligible sstables",
            "type": "size_t"
        },
        "magma_expiry_frag_threshold": {
            "default": "0.25",
            "dynamic": false,
            "descr": "All compactions perform expiry but not all sstables are visited by compaction. Magma maintains an expiry histogram across the kvstore to help determine which range of sstables need to have compaction run on them because there are a significant number of expired items. The frag threshold is the number of expired keys vs keys in the data store.",
            "type": "float"
        },
        "magma_enable_block_cache": {
            "default": "true",
            "dynamic": true,
            "descr": "The block cache is an LRU policy driven cache that is used to maintain index blocks for the sstable's btrees.",
            "type": "bool"
        },
        "magma_fragmentation_percentage": {
            "default": "50",
            "dynamic": true,
            "descr": "The percentage of fragmentation a magma bucket aims to maintain. A 100 value will disable sequence tree compactions by setting the desired fragmentation percentage to 100%. Smaller compactions of the key and local indexes will still run.",
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 10,
                    "max": 100
                }
            }
        },
        "magma_max_recovery_bytes": {
            "default": "67108864",
            "dynamic": false,
            "descr": "Maximum amount of data that is replayed from the WAL during magma recovery. When this threshold is reached magma, creates a temporary checkpoint to recover at. This is per kvstore and in bytes.",
            "type": "size_t"
        },
        "magma_max_level_0_ttl": {
            "default": "600",
            "dynamic": false,
            "descr": "Maximum time (in seconds) that data is kept in level 0 before it is merged.",
            "type": "size_t"
        },
        "magma_bloom_filter_accuracy": {
            "default": "0.99",
            "desr": "Magma maintains a bloom filter per sstable in the LSMTree. The bloom filters are used to reduce IO in case of non-existent  This config sets the accuracy of the bloom filters ie. (1 - accuracy) = false positive rate",
            "dynamic": false,
            "type": "float"
        },
        "magma_bloom_filter_accuracy_for_bottom_level": {
            "default": "0.95",
            "desr": "The bloom filters at the bottom level are used to avoid IO in case of non-existent keys. Also most of the data resides in the bottom level. This config allows for lowering of bloom filter accuracy of sstables residing in the lowermost level of the LSMTree.",
            "dynamic": false,
            "type": "float"
        },
        "retain_erroneous_tombstones": {
            "default": "true",
            "descr": "whether erroneous tombstones need to be retain during compaction. Erroneous tombstones are those that have invalid meta data in it. For example, a delete time of 0.",
	        "dynamic": true,
            "type": "bool"
        },
        "rocksdb_options": {
            "default": "bytes_per_sync=1048576,stats_dump_period_sec=600",
            "descr": "RocksDB Options, comma separated.",
            "dynamic": false,
            "type": "std::string"
        },
        "rocksdb_cf_options": {
            "default": "",
            "descr": "RocksDB Column Family Options, comma separated.",
            "dynamic": false,
            "type": "std::string"
        },
        "rocksdb_bbt_options": {
            "default": "block_size=16384,cache_index_and_filter_blocks=true,pin_l0_filter_and_index_blocks_in_cache=true,cache_index_and_filter_blocks_with_high_priority=true,index_type=kTwoLevelIndexSearch,partition_filters=true",
            "descr": "RocksDB Block Based Table Options, comma separated.",
            "dynamic": false,
            "type": "std::string"
        },
        "rocksdb_low_pri_background_threads": {
            "default": "0",
            "descr": "Number of RocksDB low priority background threads. 0 = auto-select.",
            "dynamic": false,
            "type": "size_t"
        },
        "rocksdb_high_pri_background_threads": {
            "default": "0",
            "descr": "Number of RocksDB high priority background threads. 0 = auto-select.",
            "dynamic": false,
            "type": "size_t"
        },
        "rocksdb_stats_level": {
            "default": "kExceptTimeForMutex",
            "descr": "RocksDB Statistics 'stats_level'. Possible values: {'', 'kAll', 'kExceptTimeForMutex', 'kExceptDetailedTimers'}. The empty value disables Statistics.",
            "dynamic": false,
            "type": "std::string"
        },
        "rocksdb_block_cache_ratio": {
            "default": "0.1",
            "descr": "RocksDB Block Cache ratio of the Bucket Quota. A value of 0.0 sets to the default.",
            "dynamic": false,
            "type": "float"
        },
        "rocksdb_block_cache_high_pri_pool_ratio": {
            "default": "0.9",
            "descr": "RocksDB ratio of the BlockCache quota reserved for index/filter blocks. A value of 0.0 disables the 'cache_index_and_filter_blocks_with_high_priority=true' option.",
            "dynamic": false,
            "type": "float"
        },
        "rocksdb_memtables_ratio": {
            "default": "0.1",
            "descr": "RocksDB total (i.e., all Column Families) Memtables ratio of the Bucket Quota). A value of 0.0 sets to the default.",
            "dynamic": false,
            "type": "float"
        },
        "rocksdb_default_cf_optimize_compaction": {
            "default": "none",
            "descr": "Enable Compaction Optimization for the 'default' ColumnFamily.",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "none",
                    "level",
                    "universal"
                ]
            }
        },
        "rocksdb_seqno_cf_optimize_compaction": {
            "default": "none",
            "descr": "Enable Compaction Optimization for the 'seqno' ColumnFamily.",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "none",
                    "level",
                    "universal"
                ]
            }
        },
        "rocksdb_write_rate_limit": {
            "default": "0",
            "descr": "RocksDB write rate limit (in Bytes/Sec). Use to control write rate of flush and compaction. A value of 0 sets to the default (no limit).",
            "dynamic": false,
            "type": "size_t"
        },
        "rocksdb_uc_max_size_amplification_percent": {
            "default": "200",
            "descr": "RocksDB Universal-Compaction 'max_size_amplification_percent' option. The default value is the RocksDB internal default (200).",
            "dynamic": false,
            "type": "size_t"
        },
        "seqno_persistence_timeout": {
            "default": "30",
            "descr": "Timeout in seconds after which a pending SeqnoPersistence operation is temp-failed",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 0,
                    "max": 30
                }
            }
        },
        "sync_writes_max_allowed_replicas" : {
            "default": "2",
            "descr": "The maximum number of supported replicas for SyncWrites. Attempts to issue SyncWrites against a topology with more replicas than this setting will fail with DurabilityImpossible.",
            "dynamic": false,
            "type": "size_t"
        },
        "time_synchronization": {
            "default": "disabled",
            "descr": "No longer supported. This config parameter has no effect.",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "disabled",
                    "enabled_without_drift",
                    "enabled_with_drift"
                ]
            }
        },
        "couchstore_tracing": {
            "default": "false",
            "dynamic": true,
            "descr": "Enable couchstore tracing",
            "type" : "bool"
        },
        "couchstore_write_validation": {
            "default": "false",
            "dynamic": true,
            "descr": "Validate couchstore writes ",
            "type" : "bool"
        },
        "couchstore_mprotect": {
            "default": "false",
            "dynamic": true,
            "descr": "Enable couchstore to mprotect the iobuffer",
            "type" : "bool"
        },
        "couchstore_file_cache_max_size": {
            "default": "30720",
            "dynamic": true,
            "descr": "Maximum number of couchstore files that we will keep open. Default value is 30 * 1024 (i.e. one file for each vBucket and 30 Buckets - the supported limit).",
            "type": "size_t"
        },
        "couchstore_midpoint_rollback_optimisation": {
            "default": "true",
            "dynamic": false,
            "descr": "Should we have to rollback more than half of the seqnos seen by this vBucket we will instead rollback to 0 and re-stream from the active if set to true",
            "type": "bool"
        },
        "vbucket_mapping_sanity_checking": {
            "default": "false",
            "dynamic": true,
            "descr": "Are vBucket mappings (key -> vBucket) checked by the server? This is a sanity checking mode which crc32 hashes the key to ensure that the client is supplying the expected vBucket for each key.",
            "type": "bool"
        },
        "vbucket_mapping_sanity_checking_error_mode": {
            "default": "log",
            "dynamic": true,
            "descr": "See vbucket_mapping_sanity_checking. This parameter governs how found errors are dealt with. Were we to recommend these sanity checks to a customer then a log or throw handling would likely be most appropriate, for in-house testing an abort on error is far more useful as it is immediately noticeable in test frameworks and provides the maximum amount of information.",
            "type": "std::string",
            "validator": {
                "enum": [
                    "abort",
                    "throw",
                    "log"
                ]
            }
        },
        "warmup": {
            "default": "true",
            "dynamic": false,
            "descr": "Is Warmup of existing data enabled",
            "type": "bool",
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "warmup_batch_size": {
            "default": "10000",
            "descr": "The size of each batch loaded during warmup.",
            "dynamic": false,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100000000,
                    "min": 1
                }
            }
        },
        "warmup_min_memory_threshold": {
            "default": "100",
            "descr": "Percentage of max mem warmed up before we enable traffic.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100,
                    "min": 0
                }
            }
        },
        "warmup_min_items_threshold": {
            "default": "100",
            "descr": "Percentage of total items warmed up before we enable traffic.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100,
                    "min": 0
                }
            }
        },
        "xattr_enabled": {
            "default": "true",
            "dynamic": true,
            "type": "bool"
        }
    }
}
