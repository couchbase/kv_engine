{
    "params": {
        "allow_sanitize_value_in_deletion" : {
            "default" : "true",
            "descr": "Let EPE delete/prepare/del_with_meta prune any invalid body in the payload instead of failing",
            "dynamic" : true,
            "type" : "bool"
        },
        "alog_block_size": {
            "default": "4096",
            "descr": "Logging block size.",
            "dynamic": false,
            "type": "size_t",
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "alog_path": {
            "default": "",
            "descr": "Path to the access log.",
            "dynamic": true,
            "type": "std::string",
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "access_scanner_enabled": {
            "default": "true",
            "descr": "True if access scanner task is enabled",
            "dynamic": true,
            "type": "bool",
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "alog_sleep_time": {
            "default": "1440",
            "descr": "Number of minutes between each sweep for the access log",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 4320,
                    "min": 1
                }
            },
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "alog_task_time": {
            "default": "2",
            "descr": "Hour in GMT time when access scanner task is scheduled to run",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 23,
                    "min": 0
                }
            },
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "alog_resident_ratio_threshold": {
            "default": "95",
            "desr": "Resident ratio percentage above which we do not generate access log",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100,
                    "min": 0
                }
            },
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "alog_max_stored_items": {
            "default": "1024",
            "desr": "The maximum number of items the Access Scanner will hold in memory before commiting them to disk",
            "type": "size_t",
            "dynamic": true,
            "validator": {
                "range": {
                    "min": 1
                }
            },
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "backend": {
            "default": "couchdb",
            "desr": "The storage backend to use.",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "couchdb",
                    "magma",
                    "rocksdb"
                ]
            }
        },
        "backfill_mem_threshold": {
            "default": "96",
            "desr": "Percentage of memory that backfill task is allowed to consume",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100,
                    "min": 0
                }
            }
        },
        "bfilter_enabled": {
            "default": "true",
            "desr": "Enable or disable the bloom filter",
            "dynamic": true,
            "type": "bool"
        },
        "bfilter_key_count": {
            "default": "10000",
            "desr": "Bloomfilter: Estimated key count per vbucket",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 1
                }
            }
        },
        "bfilter_fp_prob": {
            "default": "0.01",
            "desr": "Bloomfilter: Allowed probability for false positives",
            "dynamic": true,
            "type": "float"
        },
        "bfilter_residency_threshold": {
            "default": "0.1",
            "desr" : "If resident ratio (during full eviction) were found less than this threshold, compaction will include all items into bloomfilter",
            "dynamic": true,
            "type" : "float",
            "validator": {
                "range": {
                    "max": 1.0,
                    "min": 0.0
                }
            }
        },
        "bucket_type": {
            "default": "persistent",
            "descr": "Bucket type in the couchbase server",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                         "ephemeral",
                         "persistent"
                        ]
            }
        },
        "compaction_exp_mem_threshold": {
            "default": "85",
            "desr": "Memory usage threshold after which compaction will not queue expired items for deletion",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100,
                    "min": 0
                }
            }
        },
        "chk_expel_enabled": {
            "default" : "true",
            "descr": "Enable the ability to expel (remove from memory) items from a checkpoint.  An item can be expelled if all cursors in the checkpoint have iterated past the item.",
            "dynamic" : true,
            "type": "bool"
        },
        "chk_max_items": {
            "default": "10000",
            "dynamic": true,
            "type": "size_t"
        },
        "chk_period": {
            "default": "5",
            "dynamic": true,
            "type": "size_t"
        },
        "chk_remover_stime": {
            "default": "5",
            "dynamic": false,
            "type": "size_t"
        },
        "collections_enabled" : {
            "default": "true",
            "descr": "Enable the collections functionality, enabling the storage of collection metadata",
            "dynamic": false,
            "type": "bool"
        },
        "collections_max_size" : {
            "default": "1000",
            "descr": "The maximum number of collections allowed.",
            "dynamic": false,
            "type": "size_t"
        },
        "compression_mode": {
            "default": "off",
            "descr": "Determines which compression mode the bucket operates in",
	    "dynamic": true,
            "type": "std::string",
            "validator": {
                "enum": [
                         "off",
                         "passive",
                         "active"
                        ]
            }
        },
        "compaction_write_queue_cap": {
            "default": "10000",
            "desr" : "Disk write queue threshold after which compaction tasks will be made to snooze, if there are already pending compaction tasks",
	    "dynamic": true,
            "type" : "size_t",
            "validator": {
                "range": {
                    "min": 1
                }
            }
        },
        "conflict_resolution_type": {
            "default": "seqno",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "seqno",
                    "lww"
                ]
            }
        },
        "couch_bucket": {
            "default": "default",
            "descr": "The name of this bucket",
            "dynamic": false,
            "type": "std::string"
        },
        "cursor_dropping_lower_mark": {
            "default": "80",
            "descr": "Percentage of memQuota, below which checkpoint cursor dropping will not continue",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100,
                    "min": 0
                }
            }
        },
        "cursor_dropping_upper_mark": {
            "default": "95",
            "descr": "Percentage of memQuota, above which checkpoint cursor dropping will commence",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100,
                    "min": 0
                }
            }
        },
        "cursor_dropping_checkpoint_mem_upper_mark": {
            "default": "50",
            "descr": "Percentage of memQuota used by checkpoints, above which checkpoint cursor dropping will commence",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100,
                    "min": 0
                }
            }
        },
        "cursor_dropping_checkpoint_mem_lower_mark": {
            "default": "30",
            "descr": "Percentage of memQuota used by checkpoints we aim to get down to when dropping cursors",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100,
                    "min": 0
                }
            }
        },
        "data_traffic_enabled": {
            "default": "true",
            "descr": "True if we want to enable data traffic after warmup is complete",
            "dynamic": false,
            "type": "bool"
        },
        "dbname": {
            "default": "./test",
            "descr": "Path to on-disk storage.",
            "dynamic": false,
            "type": "std::string"
        },
        "dcp_consumer_control_enabled" : {
            "default": "false",
            "descr": "When true, a DcpConsumer can accept control messages. This is intended to be used by tests.",
            "dynamic": false,
            "type": "bool"
        },
        "dcp_noop_mandatory_for_v5_features": {
            "default": "true",
            "descr": "Forces clients to enable noop for v5 features",
	    "dynamic": true,
            "type": "bool"
        },

        "defragmenter_enabled": {
            "default": "true",
            "descr": "True if defragmenter task is enabled",
            "dynamic": true,
            "type": "bool"
        },
        "defragmenter_interval": {
            "default": "10.0",
            "descr": "How often defragmenter task should be run (in seconds).",
	    "dynamic": true,
            "type": "float"
        },
        "defragmenter_age_threshold": {
            "default": "10",
            "descr": "How old (measured in number of DefragmenterVisitor passes) must a document be to be considered for defragmentation.",
            "type": "size_t",
            "dynamic" : true
        },
        "defragmenter_stored_value_age_threshold": {
            "default": "10",
            "descr": "How old (measured in number of DefragmenterVisitor passes) must a StoredValue be to be considered for defragmentation.",
            "type": "size_t",
            "dynamic" : true
        },
        "defragmenter_chunk_duration": {
            "default": "20",
            "descr": "Maximum time (in ms) defragmentation task will run for before being paused (and resumed at the next defragmenter_interval).",
	    "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 1
                }
            }
        },
        "durability_timeout_task_interval": {
            "default": "25",
            "descr": "Interval (in ms) between subsequent runs of the DurabilityTimeoutTask",
            "dynamic": true,
            "type": "size_t"
        },
        "durability_min_level": {
            "default": "none",
            "descr": "Bucket Minimum Durability Level. KVEngine upgrades any write request to this min-level, if the min-level is higher than the write-level. May upgrade a NormalWrite to SyncWrite.",
            "dynamic": true,
            "type": "std::string",
            "validator": {
                "enum": [
                    "none",
                    "majority",
                    "majority_and_persist_on_master",
                    "persist_to_majority"
                ]
            }
        },
        "ephemeral_full_policy": {
            "default": "auto_delete",
            "descr": "How should an Ephemeral bucket becoming full be handled?",
            "dynamic": true,
            "type": "std::string",
            "validator": {
                "enum": [
                    "auto_delete",
                    "fail_new_data"
                ]
            },
            "requires": {
                "bucket_type": "ephemeral"
            }
        },
        "ephemeral_metadata_purge_age": {
            "default": "60",
            "descr": "Age in seconds after which Ephemeral metadata is purged entirely from memory. Purging disabled if set to -1.",
            "dynamic": true,
            "type": "ssize_t",
            "requires": {
                "bucket_type": "ephemeral"
            }
        },
        "ephemeral_metadata_purge_interval": {
            "default": "60",
            "descr": "Time in seconds between automatic, periodic runs of the Ephemeral metadata purge task. Periodic purging disabled if set to 0.",
            "dynamic": true,
            "type": "size_t",
            "requires": {
                "bucket_type": "ephemeral"
            }
        },
        "ephemeral_metadata_mark_stale_chunk_duration": {
            "default": "20",
            "descr": "Maximum time (in ms) ephemeral hash table cleaner task will run for before being paused (and resumed at the next ephemeral_metadata_purge_interval).",
            "dynamic": true,
            "type": "size_t",
            "requires": {
                "bucket_type": "ephemeral"
            }
        },
        "ephemeral_metadata_purge_stale_chunk_duration": {
            "default": "20",
            "descr": "Maximum time (in ms) ephemeral stale metadata purge task will run for before being paused (and resumed at the next ephemeral_metadata_purge_interval).",
            "dynamic": true,
            "type": "size_t",
            "requires": {
                "bucket_type": "ephemeral"
            }
        },
        "exp_pager_enabled": {
            "default": "true",
            "descr": "True if expiry pager task is enabled",
            "dynamic": true,
            "type": "bool"
        },
        "exp_pager_stime": {
            "default": "600",
            "descr": "Number of seconds between expiry pager runs.",
            "dynamic": true,
            "type": "size_t"
        },
        "exp_pager_initial_run_time": {
            "default": "-1",
            "descr": "Hour in GMT time when expiry pager can be scheduled for initial run",
            "dynamic": true,
            "type": "ssize_t",
            "validator": {
                "range": {
                    "max": 23,
                    "min": -1
                }
            }
        },
        "failpartialwarmup": {
            "default": "true",
            "descr": "If true then do not allow traffic to be enabled to the bucket if warmup didn't complete successfully",
            "dynamic": false,
            "type": "bool"
        },
        "flusher_batch_split_trigger" : {
            "default": "1000000",
            "descr": "Number of items to flush which triggers splitting the batch into multiple chunks. Individual batches may be larger than this value, as we cannot split checkpoints across multiple commits.",
            "dynamic": true,
            "type": "size_t"
        },
        "getl_default_timeout": {
            "default": "15",
            "descr": "The default timeout for a getl lock in (s)",
            "dynamic": true,
            "type": "size_t"
        },
        "getl_max_timeout": {
            "default": "30",
            "descr": "The maximum timeout for a getl lock in (s)",
            "dynamic": true,
            "type": "size_t"
        },
        "hlc_drift_ahead_threshold_us": {
            "default": "5000000",
            "descr": "The μs threshold of drift at which we will increment a vbucket's ahead counter.",
            "dynamic": true,
            "type": "size_t"
        },
        "hlc_drift_behind_threshold_us": {
            "default": "5000000",
            "descr": "The μs threshold of drift at which we will increment a vbucket's behind counter.",
            "dynamic": true,
            "type": "size_t"
        },
        "ht_locks": {
            "default": "47",
            "dynamic": false,
            "type": "size_t"
        },
        "ht_resize_interval": {
            "default": "1",
            "descr": "Interval in seconds to wait between HashtableResizerTask executions.",
            "dynamic": true,
            "type": "size_t"
        },
        "ht_size": {
            "default": "47",
            "descr": "Initial number of slots in HashTable objects.",
            "dynamic": false,
            "type": "size_t"
        },
        "item_compressor_interval": {
            "default": "250",
            "descr": "How often the item compressor task should run (in milliseconds)",
            "dynamic": true,
            "type": "size_t"
        },
        "item_compressor_chunk_duration": {
            "default": "20",
            "descr": "Maximum time (in ms) item compression task will run for before being paused (and resumed at the next item_compressor_interval).",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 1
                }
            }
        },
        "item_eviction_policy": {
            "default": "value_only",
            "descr": "Item eviction policy on cache, which is used by the item pager",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "value_only",
                    "full_eviction"
                ]
            },
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "item_eviction_age_percentage": {
            "default": "30",
            "descr": "The age percentage used when determining the age threshold in the hifi_mfu eviction policy.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 0,
                    "max": 100
                }
            }
        },
        "item_eviction_freq_counter_age_threshold": {
            "default": "1",
            "decr": "The threshold for determining at what execution frequency we consider age when selecting items for eviction.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 0,
                    "max": 255
                }
            }
        },
        "item_freq_decayer_chunk_duration": {
            "default": "20",
            "descr": "Maximum time (in ms) itemFreqDecayer task will run for before being paused.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 1
                }
            }
        },
        "item_freq_decayer_percent": {
            "default": "50",
            "descr": "The percent that the frequency counter of a document is decayed when visited by item_freq_decayer.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 0,
                    "max": 100
                }
            }
        },
        "item_num_based_new_chk": {
            "default": "true",
            "descr": "True if the number of items in the current checkpoint plays a role in a new checkpoint creation",
            "dynamic": true,
            "type": "bool"
        },
        "keep_closed_chks": {
            "default": "false",
            "descr": "True if we want to keep the closed checkpoints for each vbucket unless the memory usage is above high water mark",
            "dynamic": true,
            "type": "bool"
        },
        "connection_manager_interval": {
            "default": "1",
            "descr": "How often connection manager task should be run (in seconds).",
            "type": "size_t",
            "dynamic": true,
            "validator": {
                "range": {
                    "min": 1
                }
            }
        },
        "max_checkpoints": {
            "default": "2",
            "dynamic": true,
            "type": "size_t"
        },
        "max_failover_entries": {
            "default": "25",
            "descr": "maximum number of failover log entries",
            "dynamic": false,
            "type": "size_t"
        },
        "max_item_privileged_bytes": {
            "default": "(1024 * 1024)",
            "descr": "Maximum number of bytes allowed for 'privileged' (system) data for an item in addition to the max_item_size bytes",
            "dynamic": true,
            "type": "size_t"
        },
        "max_item_size": {
            "default": "(20 * 1024 * 1024)",
            "descr": "Maximum number of bytes allowed for an item",
            "dynamic": true,
            "type": "size_t"
        },
        "max_size": {
            "default": "(100 * 1024 * 1024)",
            "dynamic": true,
            "type": "size_t",
            "descr": "Memory quota (in bytes) for this bucket.",
            "aliases":["cache_size"]
        },
        "max_ttl":{
            "default": "0",
            "descr": "A maximum TTL (in seconds) that will apply to all new documents, documents set with no TTL will be given this value. A value of 0 means this is disabled",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "min": 0,
                    "max": 2147483647
                }
            }
        },
        "max_vbuckets": {
            "default": "1024",
            "descr": "Maximum number of vbuckets expected",
            "dynamic": false,
            "type": "size_t"
        },
        "max_threads": {
            "default": "0",
            "descr": "Maximum number of threads of any single class (0 = automatically select based on core count)",
            "dynamic": false,
            "type": "size_t"
        },
        "max_num_shards": {
            "default": "0",
            "descr": "Maximum mumber of shards (0 = auto-configure)",
            "dynamic": false,
            "type": "size_t"
        },
        "max_num_workers": {
            "default": "4",
            "descr": "Bucket Priority relative to other buckets",
            "dynamic": false,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 8,
                    "min": 1
                }
            }
        },
        "mem_used_merge_threshold_percent" : {
            "default": "0.5",
            "descr": "What percent of max_data size should we allow the estimated total memory to lag by (EPStats::getEstimatedTotalMemoryUsed)",
            "dynamic": true,
            "type": "float",
            "validator": {
                "range": {
                    "max": 100.0,
                    "min": 0.0
                }
            }
        },
        "num_reader_threads": {
            "default": "0",
            "descr": "Number of reader threads (0 = Default, -1 = Disk IO Optimized)",
            "dynamic": true,
            "type": "ssize_t",
            "validator": {
                "range": {
                    "max": 512,
                    "min": -1
                }
            }
        },
        "num_writer_threads": {
            "default": "0",
            "descr": "Number of writer threads (0 = Default, -1 = Disk IO Optimized)",
            "dynamic": true,
            "type": "ssize_t",
            "validator": {
                "range": {
                    "max": 512,
                    "min": -1
                }
            }
        },
        "num_auxio_threads": {
            "default": "0",
            "descr": "Throttle max number of aux io threads",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 512,
                    "min": 0
                }
            }
        },
        "num_nonio_threads": {
            "default": "0",
            "descr": "Throttle max number of non io threads",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 512,
                    "min": 0
                }
            }
        },
        "mem_high_wat": {
            "default": "max",
            "dynamic": true,
            "type": "size_t"
        },
        "mem_low_wat": {
            "default": "max",
            "dynamic": true,
            "type": "size_t"
        },
        "mutation_mem_threshold": {
            "default": "93",
            "desr": "Percentage of memory that can be used before mutations return tmpOOMs",
            "dynamic": true,
            "type": "size_t",
            "validator" : {
                "range" : {
                    "max": 100,
                    "min": 0
                }
            }
        },
        "pager_active_vb_pcnt": {
            "default": "40",
            "descr": "Active vbuckets paging percentage",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 50,
                    "min": 0
                }
            }
        },
        "pager_sleep_time_ms": {
            "default": "5000",
            "descr": "How long in milliseconds the ItemPager will sleep for when not being requested to run",
            "dynamic": true,
            "type": "size_t"
        },
        "replication_throttle_cap_pcnt": {
            "default": "10",
            "descr": "Percentage of total items in write queue at which we throttle replication input",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100,
                    "min": 0
                }
            }
        },
        "replication_throttle_queue_cap": {
            "default": "-1",
            "descr": "Max size of a write queue to throttle incoming replication input.",
            "dynamic": true,
            "type": "ssize_t",
            "validator": {
                "range": {
                    "max": 100000000,
                    "min": -1
                }
            }
        },
        "replication_throttle_threshold": {
            "default": "99",
            "descr": "Percentage of max mem at which we begin NAKing replication input.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100,
                    "min": 0
                }
            }
        },
        "uuid": {
            "default": "",
            "descr": "The UUID for the bucket",
            "dynamic" : false,
            "type": "std::string"
        },
        "dcp_backfill_byte_limit": {
            "default": "20972856",
            "descr": "Max bytes a connection can backfill into memory before backfill is paused",
            "dynamic": false,
            "type": "size_t"
        },
        "dcp_blacklist_fts_connection_logs": {
            "default": "true",
            "descr": "MB-28468: FTS creates streams for non-existing vBuckets which spams memcached logs. Blacklist FTS connections by setting level to critical until fixed.",
            "dynamic": true,
            "type": "bool"
        },
        "dcp_flow_control_policy": {
            "default": "aggressive",
            "descr": "Flow control policy used on consumer side buffer",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                         "none",
                         "static",
                         "dynamic",
                         "aggressive"
                        ]
            }
        },
        "dcp_conn_buffer_size": {
            "default": "10485760",
            "descr": "Size in bytes of an dcp consumer connection buffer",
            "dynamic": true,
            "type": "size_t"
        },
        "dcp_conn_buffer_size_max": {
            "default": "52428800",
            "descr": "Max size in bytes of an dcp consumer connection buffer",
            "dynamic": true,
            "type": "size_t"
        },
        "dcp_conn_buffer_size_perc": {
            "default": "1",
            "descr": "Percentage of memQuota for a dcp consumer connection buffer in dynamic flow ctl policy",
            "type": "size_t",
            "dynamic": true,
            "validator": {
                "range": {
                    "max": 10,
                    "min": 1
                }
            }
        },
        "dcp_conn_buffer_size_aggr_mem_threshold": {
            "default": "10",
            "descr": "Aggr mem usage by all dcp conns (as percentage of memQuota) after which only dcp_conn_buffer_size is allocated",
            "type": "size_t",
            "dynamic": true,
            "validator": {
                "range": {
                    "max": 20,
                    "min": 1
                }
            }
        },
        "dcp_conn_buffer_size_aggressive_perc": {
            "default": "5",
            "descr": "Percentage of memQuota for all dcp consumer connection buffers in aggressive flow ctl policy",
            "type": "size_t",
            "dynamic": true,
            "validator": {
                "range": {
                    "max": 20,
                    "min": 1
                }
            }
        },
        "dcp_enable_noop": {
            "default": "true",
            "descr": "Whether DCP Consumer connections should attempt to negotiate no-ops with the Producer",
            "dynamic": true,
            "type": "bool"
        },
        "dcp_min_compression_ratio": {
            "default": "0.85",
            "desr": "Compression ratio to be achieved above which producer will ship documents as is",
            "dynamic": true,
            "type": "float",
            "validator": {
                "range": {
                    "min": 0.0
                }
            }
        },
        "dcp_idle_timeout": {
            "default": "360",
            "descr": "The maximum number of seconds between dcp messages before a connection is disconnected",
            "dynamic": true,
            "type": "size_t"
        },
        "dcp_noop_tx_interval": {
            "default": "1",
            "descr": "The time interval in seconds between noop messages being sent to the consumer",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max" : 360,
                    "min" : 1
                }
            }
        },
        "dcp_scan_byte_limit": {
            "default": "4194304",
            "descr": "Max bytes that can be read in a single backfill scan before yielding",
            "dynamic": false,
            "type": "size_t"
        },
        "dcp_scan_item_limit": {
            "default": "4096",
            "descr": "Max items that can be read in a single backfill scan before yielding",
            "dynamic": false,
            "type": "size_t"
        },
        "dcp_takeover_max_time": {
            "default": "60",
            "descr": "Max amount of time for takeover send (in seconds) after which front end ops would return ETMPFAIL",
            "dynamic": true,
            "type": "size_t"
        },
        "dcp_producer_snapshot_marker_yield_limit": {
            "default": "10",
            "descr": "The number of snapshots before ActiveStreamCheckpointProcessorTask::run yields.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100000000,
                    "min": 1
                }
            }
        },
        "dcp_consumer_process_buffered_messages_yield_limit" : {
            "default": "10",
            "descr": "The number of processBufferedMessages iterations before forcing the task to yield.",
	        "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100000000,
                    "min": 1
                }
            }
        },
        "dcp_consumer_process_buffered_messages_batch_size" : {
            "default": "10",
            "descr": "The maximum number of items stream->processBufferedMessages will consume.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100000000,
                    "min": 1
                }
            }
        },
        "fsync_after_every_n_bytes_written": {
            "default": "16777216",
            "descr": "Perform a file sync() operation after every N bytes written. Disabled if set to 0.",
            "dynamic": true,
            "type" : "size_t"
        },
        "min_compression_ratio": {
            "default": "1.2",
            "descr": "specifies a minimum compression ratio below which storing the document will be stored as uncompressed.",
            "dynamic": true,
            "type" : "float",
            "validator": {
                "range": {
                    "min": 0.0
                }
            }
        },
        "magma_delete_memtable_writecache": {
            "default": "8192",
            "dynamic": false,
            "descr": "Magma uses a lazy update model to maintain the sequence index. It maintains a list of deleted seq #s that were deleted from the key Index.",
            "type": "size_t"
        },
        "magma_delete_frag_ratio": {
            "default": "0.5",
            "dynamic": false,
            "descr": "Magma compaction always removes duplicate keys but not all sstables are visited during compaction.. This is the minimum fragmentation ratio threshold for when a compaction will be triggerred.",
            "type": "float"
        },
        "magma_max_commit_points": {
            "default": "5",
            "dynamic": false,
            "descr": "Maximum # of commit points retained for rollback.",
            "type": "size_t"
        },
        "magma_commit_point_interval": {
            "default": "2",
            "dynamic": false,
            "descr": "frequency of commit point interval; in minutes.",
            "type": "size_t"
        },
        "magma_value_separation_size": {
            "default": "32",
            "dynamic": false,
            "descr": "Values smaller than this will not be separated from their keys.",
            "type": "size_t"
        },
        "magma_min_write_cache": {
            "default": "8388608",
            "dynamic": false,
            "descr": "Magma uses a common skiplist to buffer all items at the shard level called the write cache. The write cache contains items from all the kvstores that are part of the shard and when it is flushed, each kvstore will receive a few items each. A too small write cache can lead to very small sstables and high write amplification. A lower value can be used if the number of kvstores per shard is smaller.",
            "type": "size_t"
        },
        "magma_max_write_cache": {
            "default": "134217728",
            "dynamic": false,
            "descr": "Magma uses a common skiplist to buffer all items at the shard level called the write cache. The write cache contains items from all the kvstores that are part of the shard and when it is flushed, each kvstore will receive a few items each. A too large write cache can lead to high space amplification.",
            "type": "size_t"
        },
        "magma_mem_quota_ratio": {
            "default": "0.1",
            "descr": "Magma total memory ratio of the Bucket Quota across all shards.",
            "dynamic": false,
            "type": "float"
        },
        "magma_wal_buffer_size": {
            "default": "2097152",
            "dynamic": false,
            "descr": "The WAL buffer is used to stage items to the write ahead log along with control information like begin & end transaction. The WAL can support multiple buffers allowing for improved write performance when transaction batches are > magma_wal_buffer_size. This value should be increased if the size of item batches are > 2MB, whether its because the item sizes are > 2MB or the number of items in a batch > 2MB.",
            "type": "size_t"
        },
        "magma_wal_num_buffers": {
            "default": "1",
            "dynamic": false,
            "descr": "When batches of items are large in size, magma WAL can take advantage of double buffering to speed up persistence by flushing intermediate batches to disk. Atomicity is maintained through the use of begin/end transaction control records.",
            "type": "size_t"
        },
        "magma_num_flushers": {
            "default": "1",
            "dynamic": false,
            "descr": "Number of threads to write filled memtables to disk.",
            "type": "size_t"
        },
        "magma_num_compactors": {
            "default": "4",
            "dynamic": false,
            "descr": "Number of background compactor threads used by magma.",
            "type": "size_t"
        },
        "magma_commit_point_every_batch": {
            "default": "false",
            "dynamic": false,
            "descr": "Couchstore generates a potential commit point at the end of every batch of items. During normal operation, Magma commit points are take at every magma_commit_point_interval. Many of the tests require more frequent commit points so this configuration parameter makes sure every batch generates a commit point. Should be used for testing only!",
            "type": "bool"
        },
        "magma_enable_upsert": {
            "default": "false",
            "dynamic": false,
            "descr": "When true, the kv_engine will utilize Magma's upsert capabiltiy but accurate document counts for the data store or collections can not be maintained.",
            "type": "bool"
        },
        "magma_expiry_frag_threshold": {
            "default": "0.25",
            "dynamic": false,
            "descr": "All compactions perform expiry but not all sstables are visited by compaction. Magma maintains an expiry histogram across the kvstore to help determine which range of sstables need to have compaction run on them because there are a significant number of expired items. The frag threshold is the number of expired keys vs keys in the data store.",
            "type": "float"
        },
        "magma_tombstone_frag_threshold": {
            "default": "0.25",
            "dynamic": false,
            "descr": "All compactions perform tombstone removal but not all sstables are visited by compaction. Magma tracks tombstone counts and will perform compaction on the range of sstables which have a significant number of tombstones. The frag threshold is the number of tombstones vs keys in the data store.",
            "type": "float"
        },
        "retain_erroneous_tombstones": {
            "default": "true",
            "descr": "whether erroneous tombstones need to be retain during compaction. Erroneous tombstones are those that have invalid meta data in it. For example, a delete time of 0.",
	        "dynamic": true,
            "type": "bool"
        },
        "rocksdb_options": {
            "default": "bytes_per_sync=1048576,stats_dump_period_sec=600",
            "descr": "RocksDB Options, comma separated.",
            "dynamic": false,
            "type": "std::string"
        },
        "rocksdb_cf_options": {
            "default": "",
            "descr": "RocksDB Column Family Options, comma separated.",
            "dynamic": false,
            "type": "std::string"
        },
        "rocksdb_bbt_options": {
            "default": "block_size=16384,cache_index_and_filter_blocks=true,pin_l0_filter_and_index_blocks_in_cache=true,cache_index_and_filter_blocks_with_high_priority=true,index_type=kTwoLevelIndexSearch,partition_filters=true",
            "descr": "RocksDB Block Based Table Options, comma separated.",
            "dynamic": false,
            "type": "std::string"
        },
        "rocksdb_low_pri_background_threads": {
            "default": "0",
            "descr": "Number of RocksDB low priority background threads. 0 = auto-select.",
            "dynamic": false,
            "type": "size_t"
        },
        "rocksdb_high_pri_background_threads": {
            "default": "0",
            "descr": "Number of RocksDB high priority background threads. 0 = auto-select.",
            "dynamic": false,
            "type": "size_t"
        },
        "rocksdb_stats_level": {
            "default": "kExceptTimeForMutex",
            "descr": "RocksDB Statistics 'stats_level'. Possible values: {'', 'kAll', 'kExceptTimeForMutex', 'kExceptDetailedTimers'}. The empty value disables Statistics.",
            "dynamic": false,
            "type": "std::string"
        },
        "rocksdb_block_cache_ratio": {
            "default": "0.1",
            "descr": "RocksDB Block Cache ratio of the Bucket Quota. A value of 0.0 sets to the default.",
            "dynamic": false,
            "type": "float"
        },
        "rocksdb_block_cache_high_pri_pool_ratio": {
            "default": "0.9",
            "descr": "RocksDB ratio of the BlockCache quota reserved for index/filter blocks. A value of 0.0 disables the 'cache_index_and_filter_blocks_with_high_priority=true' option.",
            "dynamic": false,
            "type": "float"
        },
        "rocksdb_memtables_ratio": {
            "default": "0.1",
            "descr": "RocksDB total (i.e., all Column Families) Memtables ratio of the Bucket Quota). A value of 0.0 sets to the default.",
            "dynamic": false,
            "type": "float"
        },
        "rocksdb_default_cf_optimize_compaction": {
            "default": "none",
            "descr": "Enable Compaction Optimization for the 'default' ColumnFamily.",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "none",
                    "level",
                    "universal"
                ]
            }
        },
        "rocksdb_seqno_cf_optimize_compaction": {
            "default": "none",
            "descr": "Enable Compaction Optimization for the 'seqno' ColumnFamily.",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "none",
                    "level",
                    "universal"
                ]
            }
        },
        "rocksdb_write_rate_limit": {
            "default": "0",
            "descr": "RocksDB write rate limit (in Bytes/Sec). Use to control write rate of flush and compaction. A value of 0 sets to the default (no limit).",
            "dynamic": false,
            "type": "size_t"
        },
        "rocksdb_uc_max_size_amplification_percent": {
            "default": "200",
            "descr": "RocksDB Universal-Compaction 'max_size_amplification_percent' option. The default value is the RocksDB internal default (200).",
            "dynamic": false,
            "type": "size_t"
        },
        "scopes_max_size" : {
            "default": "100",
            "descr": "The maximum number of scopes allowed.",
            "dynamic": false,
            "type": "size_t"
        },
        "sync_writes_max_allowed_replicas" : {
            "default": "2",
            "descr": "The maximum number of supported replicas for SyncWrites. Attempts to issue SyncWrites against a topology with more replicas than this setting will fail with DurabilityImpossible.",
            "dynamic": false,
            "type": "size_t"
        },
        "time_synchronization": {
            "default": "disabled",
            "descr": "No longer supported. This config parameter has no effect.",
            "dynamic": false,
            "type": "std::string",
            "validator": {
                "enum": [
                    "disabled",
                    "enabled_without_drift",
                    "enabled_with_drift"
                ]
            }
        },
        "couchstore_tracing": {
            "default": "false",
            "dynamic": true,
            "descr": "Enable couchstore tracing",
            "type" : "bool"
        },
        "couchstore_write_validation": {
            "default": "false",
            "dynamic": true,
            "descr": "Validate couchstore writes ",
            "type" : "bool"
        },
        "couchstore_mprotect": {
            "default": "false",
            "dynamic": true,
            "descr": "Enable couchstore to mprotect the iobuffer",
            "type" : "bool"
        },
        "warmup": {
            "default": "true",
            "dynamic": false,
            "descr": "Is Warmup of existing data enabled",
            "type": "bool",
            "requires": {
                "bucket_type": "persistent"
            }
        },
        "warmup_batch_size": {
            "default": "10000",
            "descr": "The size of each batch loaded during warmup.",
            "dynamic": false,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100000000,
                    "min": 1
                }
            }
        },
        "warmup_backfill_scan_chunk_duration": {
            "default": "10",
            "descr": "The duration (in ms) after which warmup's backfill scans will yield and re-schedule; allowing other tasks on the same threads to run.",
            "dynamic": false,
            "type": "size_t",
            "requires": {
                "bucket_type": "persistent"
            },
            "comment": "Empirical testing using perf_bucket_warmup() in ep_perfsuite has shown that 10ms is a sweet spot for back filling maxDuration as it allows ~1000 items to be loaded before meeting the deadline and doesn't show a regression as compared with before the back filling tasks being performed in a pause/resume fashion."
        },
        "warmup_min_memory_threshold": {
            "default": "100",
            "descr": "Percentage of max mem warmed up before we enable traffic.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100,
                    "min": 0
                }
            }
        },
        "warmup_min_items_threshold": {
            "default": "100",
            "descr": "Percentage of total items warmed up before we enable traffic.",
            "dynamic": true,
            "type": "size_t",
            "validator": {
                "range": {
                    "max": 100,
                    "min": 0
                }
            }
        },
        "xattr_enabled": {
            "default": "true",
            "dynamic": true,
            "type": "bool"
        }
    }
}
